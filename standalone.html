<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì´ë¯¸ì§€ ì˜ìƒ ì œì‘ê¸° (FFmpeg.wasm)</title>
    <!-- FFmpeg.wasm CDN (ì•ˆì • ë²„ì „) -->
    <script src="https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.11.6/dist/ffmpeg.min.js"></script>
    <style>
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        font-family: -apple-system, BlinkMacSystemFont, "Malgun Gothic", "ë§‘ì€ ê³ ë”•", "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    }

    body {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        padding: 20px;
    }

    .container {
        max-width: 1200px;
        margin: 0 auto;
        background: white;
        border-radius: 20px;
        box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        overflow: hidden;
    }

    .header {
        background: linear-gradient(45deg, #667eea, #764ba2);
        color: white;
        padding: 30px;
        text-align: center;
    }

    .header h1 {
        font-size: 2.5em;
        margin-bottom: 10px;
    }

    .header p {
        font-size: 1.1em;
        opacity: 0.9;
    }

    .ffmpeg-badge {
        display: inline-block;
        background: rgba(255,255,255,0.2);
        padding: 8px 15px;
        border-radius: 20px;
        font-size: 0.9em;
        margin-top: 10px;
    }

    .main-content {
        padding: 40px;
    }

    .upload-section {
        margin-bottom: 40px;
    }

    .upload-section h2 {
        color: #495057;
        margin-bottom: 20px;
        font-size: 1.5em;
    }

    .upload-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
        gap: 15px;
        margin-top: 20px;
    }

    .upload-slot {
        position: relative;
        aspect-ratio: 16/9;
        border: 2px dashed #ddd;
        border-radius: 10px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.3s ease;
        background: #f8f9fa;
    }

    .upload-slot:hover {
        border-color: #667eea;
        background: #f0f0ff;
    }

    .upload-slot.has-image {
        border-color: #28a745;
        background: none;
    }

    .upload-slot.dragging {
        opacity: 0.5;
        cursor: move;
    }

    .upload-slot.drag-over {
        border-color: #667eea;
        background: #f0f0ff;
        transform: scale(1.05);
    }

    .upload-slot[draggable="true"] {
        cursor: move;
    }

    .upload-slot input {
        position: absolute;
        opacity: 0;
        width: 100%;
        height: 100%;
        cursor: pointer;
    }

    .upload-slot img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        border-radius: 8px;
    }

    .slot-number {
        position: absolute;
        top: 5px;
        left: 5px;
        background: rgba(0,0,0,0.7);
        color: white;
        padding: 2px 8px;
        border-radius: 12px;
        font-size: 12px;
        font-weight: bold;
    }

    .remove-btn {
        position: absolute;
        top: 5px;
        right: 5px;
        background: #dc3545;
        color: white;
        border: none;
        border-radius: 50%;
        width: 24px;
        height: 24px;
        cursor: pointer;
        font-size: 14px;
    }

    .settings-section {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 30px;
        margin-bottom: 40px;
    }

    .setting-group {
        background: #f8f9fa;
        padding: 25px;
        border-radius: 15px;
        border: 1px solid #e9ecef;
    }

    .setting-group h3 {
        color: #495057;
        margin-bottom: 20px;
        font-size: 1.3em;
        display: flex;
        align-items: center;
        gap: 10px;
    }

    .form-group {
        margin-bottom: 15px;
    }

    label {
        display: block;
        margin-bottom: 8px;
        font-weight: 600;
        color: #555;
    }

    select, input, textarea {
        width: 100%;
        padding: 10px;
        border: 2px solid #e9ecef;
        border-radius: 8px;
        font-size: 14px;
        transition: border-color 0.3s ease;
    }

    select:focus, input:focus, textarea:focus {
        outline: none;
        border-color: #667eea;
    }

    .canvas-section {
        text-align: center;
        margin-bottom: 40px;
    }

    .canvas-section h2 {
        color: #495057;
        margin-bottom: 20px;
        font-size: 1.5em;
    }

    .canvas-container {
        display: inline-block;
        position: relative;
        border-radius: 15px;
        overflow: hidden;
        box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        margin: 20px 0;
    }

    #videoCanvas {
        display: block;
        max-width: 100%;
        height: auto;
    }

    .ratio-indicator {
        position: absolute;
        top: 10px;
        right: 10px;
        background: rgba(0,0,0,0.7);
        color: white;
        padding: 5px 10px;
        border-radius: 15px;
        font-size: 12px;
        font-weight: bold;
    }

    .controls {
        display: flex;
        justify-content: center;
        gap: 15px;
        margin-top: 20px;
        flex-wrap: wrap;
    }

    .btn {
        padding: 12px 24px;
        border: none;
        border-radius: 25px;
        font-size: 16px;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .btn-primary {
        background: linear-gradient(45deg, #667eea, #764ba2);
        color: white;
    }

    .btn-secondary {
        background: #6c757d;
        color: white;
    }

    .btn-success {
        background: #28a745;
        color: white;
    }

    .btn-danger {
        background: #dc3545;
        color: white;
    }

    .btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(0,0,0,0.2);
    }

    .btn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        transform: none;
    }

    .status-section {
        background: #f8f9fa;
        padding: 20px;
        border-radius: 15px;
        text-align: center;
        margin-top: 30px;
    }

    .status {
        font-size: 16px;
        font-weight: 500;
        color: #495057;
    }

    .progress-bar {
        width: 100%;
        height: 8px;
        background: #e9ecef;
        border-radius: 4px;
        margin: 15px 0;
        overflow: hidden;
    }

    .progress-fill {
        height: 100%;
        background: linear-gradient(45deg, #667eea, #764ba2);
        border-radius: 4px;
        width: 0%;
        transition: width 0.3s ease;
    }

    section h2 {
        color: #495057;
        margin-bottom: 20px;
        font-size: 1.5em;
    }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ¬ ì´ë¯¸ì§€ ì˜ìƒ ì œì‘ê¸°</h1>
            <p>ì´ë¯¸ì§€ë“¤ì„ ì„ íƒí•˜ì—¬ ìë§‰ì´ í¬í•¨ëœ ë©‹ì§„ ì˜ìƒì„ ë§Œë“¤ì–´ë³´ì„¸ìš”!</p>
            <div class="ffmpeg-badge">âš¡ FFmpeg.wasm ì ìš© - ë§ˆì§€ë§‰ í”„ë ˆì„ ì™„ë²½ ë Œë”ë§</div>
        </div>

        <div class="main-content">
            <!-- ê°„ë‹¨í•œ í…ŒìŠ¤íŠ¸ ë²„ì „ -->
            <section class="upload-section">
                <h2>ğŸ“¸ ì´ë¯¸ì§€ ì—…ë¡œë“œ (ê°„ë‹¨ í…ŒìŠ¤íŠ¸)</h2>

                <div style="margin-bottom: 30px; text-align: center;">
                    <button class="btn btn-primary" onclick="document.getElementById('bulkUpload').click()" style="font-size: 18px; padding: 15px 30px;">
                        ğŸš€ ì´ë¯¸ì§€ ì—…ë¡œë“œ (ìµœëŒ€ 10ì¥)
                    </button>
                    <input type="file" id="bulkUpload" multiple accept="image/*" onchange="processBulkUpload()" style="display: none;">
                    <p style="font-size: 14px; color: #666; margin-top: 10px;">ğŸ’¡ ì—¬ëŸ¬ ì´ë¯¸ì§€ë¥¼ ì„ íƒí•˜ë©´ ìë™ìœ¼ë¡œ ìŠ¬ë¡¯ì— ë°°ì¹˜ë©ë‹ˆë‹¤</p>
                </div>

                <div class="upload-grid" id="uploadGrid">
                    <!-- ì—…ë¡œë“œ ìŠ¬ë¡¯ë“¤ì´ ì—¬ê¸°ì— ë™ì  ìƒì„± -->
                </div>
            </section>

            <!-- ì„¤ì • ì„¹ì…˜ -->
            <div class="settings-section">
                <div class="setting-group">
                    <h3>ğŸ¬ ì˜ìƒ ì„¤ì •</h3>
                    <div class="form-group">
                        <label for="imageDuration">ì´ë¯¸ì§€ë‹¹ ì¬ìƒ ì‹œê°„ (ì´ˆ):</label>
                        <input type="number" id="imageDuration" min="0.5" max="10" step="0.5" value="2">
                    </div>
                    <div class="form-group">
                        <label for="videoQuality">ì˜ìƒ í™”ì§ˆ:</label>
                        <select id="videoQuality">
                            <option value="2500000">í‘œì¤€ í™”ì§ˆ (2.5Mbps)</option>
                            <option value="5000000">ê³ í™”ì§ˆ (5Mbps)</option>
                            <option value="8000000" selected>ìµœê³ í™”ì§ˆ (8Mbps)</option>
                        </select>
                    </div>
                </div>

                <div class="setting-group">
                    <h3>ğŸ“ ìë§‰ ì„¤ì •</h3>
                    <div class="form-group">
                        <label for="subtitleFontSize">í°íŠ¸ í¬ê¸°:</label>
                        <input type="range" id="subtitleFontSize" min="24" max="80" value="48" oninput="updateFontSizeDisplay()">
                        <small>í˜„ì¬ í¬ê¸°: <span id="fontSizeValue">48px</span></small>
                    </div>
                    <div class="form-group">
                        <label for="subtitleColor">ê¸€ì ìƒ‰ìƒ:</label>
                        <input type="color" id="subtitleColor" value="#ffffff">
                    </div>
                </div>
            </div>

            <!-- ìë§‰ ì…ë ¥ -->
            <section class="upload-section">
                <h2>ğŸ’¬ ìë§‰ ì„¤ì •</h2>
                <div id="subtitleInputs" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 15px;">
                    <p style="text-align: center; color: #666; font-style: italic;">ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•˜ë©´ ìë§‰ì„ ì„¤ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p>
                </div>
            </section>

            <!-- ë¯¸ë¦¬ë³´ê¸° -->
            <section class="canvas-section">
                <h2>ğŸ‘€ ë¯¸ë¦¬ë³´ê¸°</h2>
                <div class="canvas-container">
                    <canvas id="videoCanvas" width="1080" height="1080"></canvas>
                    <div class="ratio-indicator" id="ratioIndicator">1:1</div>
                </div>
            </section>

            <!-- ì˜ìƒ ì œì‘ -->
            <section>
                <h2>ğŸ¥ ì˜ìƒ ì œì‘</h2>
                <div class="controls">
                    <button class="btn btn-success" onclick="startRecording()" id="recordBtn">ğŸ”´ FFmpegìœ¼ë¡œ ì˜ìƒ ì œì‘</button>
                    <button class="btn btn-danger" onclick="stopRecording()" id="stopBtn" disabled>â¹ï¸ ì œì‘ ì¤‘ì§€</button>
                </div>

                <div class="status-section">
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill"></div>
                    </div>
                    <div class="status" id="status">FFmpeg ë¡œë”© ì¤‘...</div>
                </div>
            </section>
        </div>
    </div>

    <script>
        // ì „ì—­ ë³€ìˆ˜
        const MAX_IMAGES = 10; // í…ŒìŠ¤íŠ¸ìš©ìœ¼ë¡œ 10ê°œë¡œ ì œí•œ
        let images = new Array(MAX_IMAGES).fill(null);
        let subtitles = new Array(MAX_IMAGES).fill('');
        let currentImageIndex = 0;
        let isRecording = false;

        // FFmpeg.wasm ë³€ìˆ˜
        let ffmpeg = null;
        let ffmpegLoaded = false;

        // ì´ˆê¸°í™”
        document.addEventListener('DOMContentLoaded', () => {
            initializeUploadSlots();
            drawCurrentImage();
            loadFFmpeg();
        });

        // FFmpeg.wasm ì´ˆê¸°í™”
        async function loadFFmpeg() {
            try {
                const { createFFmpeg, fetchFile } = FFmpeg;
                ffmpeg = createFFmpeg({
                    log: true,
                    corePath: 'https://cdn.jsdelivr.net/npm/@ffmpeg/core@0.11.0/dist/ffmpeg-core.js'
                });

                ffmpeg.setProgress(({ ratio }) => {
                    if (ratio > 0 && ratio < 1) {
                        const percent = Math.round(ratio * 100);
                        updateStatus('FFmpeg ì¸ì½”ë”© ì¤‘... ' + percent + '%');
                    }
                });

                updateStatus('FFmpeg ë¡œë”© ì¤‘... (ìµœì´ˆ 1íšŒë§Œ ì†Œìš”, ì•½ 30ì´ˆ)');
                await ffmpeg.load();
                ffmpegLoaded = true;
                window.fetchFile = fetchFile; // ì „ì—­ìœ¼ë¡œ ì €ì¥
                updateStatus('âœ… FFmpeg ë¡œë”© ì™„ë£Œ! ì´ì œ ì˜ìƒì„ ì œì‘í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
                console.log('FFmpeg.wasm loaded successfully');
            } catch (error) {
                console.error('FFmpeg ë¡œë”© ì‹¤íŒ¨:', error);
                updateStatus('âŒ FFmpeg ë¡œë”© ì‹¤íŒ¨: ' + error.message);
                ffmpegLoaded = false;
            }
        }

        // ì—…ë¡œë“œ ìŠ¬ë¡¯ ì´ˆê¸°í™”
        function initializeUploadSlots() {
            const uploadGrid = document.getElementById('uploadGrid');
            uploadGrid.innerHTML = '';
            for (let i = 0; i < MAX_IMAGES; i++) {
                const slot = document.createElement('div');
                slot.className = 'upload-slot';
                slot.dataset.index = i;
                slot.innerHTML = `
                    <input type="file" accept="image/*" onchange="handleImageUpload(${i}, this)">
                    <div class="slot-number">${i + 1}</div>
                    <div style="font-size: 24px; color: #999;">+</div>
                `;
                uploadGrid.appendChild(slot);
            }
        }

        // ì¼ê´„ ì—…ë¡œë“œ
        function processBulkUpload() {
            const bulkInput = document.getElementById('bulkUpload');
            const files = Array.from(bulkInput.files);
            if (files.length === 0) return;

            const emptySlots = [];
            for (let i = 0; i < MAX_IMAGES; i++) {
                if (images[i] === null) emptySlots.push(i);
            }

            if (emptySlots.length === 0) {
                updateStatus('ëª¨ë“  ìŠ¬ë¡¯ì´ ê°€ë“ ì°¼ìŠµë‹ˆë‹¤!');
                bulkInput.value = '';
                return;
            }

            const uploadCount = Math.min(files.length, emptySlots.length);
            let completedUploads = 0;

            files.slice(0, uploadCount).forEach((file, fileIndex) => {
                const slotIndex = emptySlots[fileIndex];
                const reader = new FileReader();

                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        images[slotIndex] = img;
                        const slot = document.querySelectorAll('.upload-slot')[slotIndex];
                        slot.classList.add('has-image');
                        slot.innerHTML = `
                            <img src="${event.target.result}" alt="ì´ë¯¸ì§€ ${slotIndex + 1}">
                            <div class="slot-number">${slotIndex + 1}</div>
                            <button class="remove-btn" onclick="removeImage(${slotIndex})">Ã—</button>
                        `;

                        completedUploads++;
                        if (completedUploads === uploadCount) {
                            generateSubtitleInputs();
                            updateStatus(uploadCount + 'ê°œ ì´ë¯¸ì§€ ì—…ë¡œë“œ ì™„ë£Œ!');
                            bulkInput.value = '';
                            drawCurrentImage();
                        }
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            });
        }

        // ê°œë³„ ì´ë¯¸ì§€ ì—…ë¡œë“œ
        function handleImageUpload(index, input) {
            const file = input.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    images[index] = img;
                    const slot = input.parentElement;
                    slot.classList.add('has-image');
                    slot.innerHTML = `
                        <img src="${event.target.result}" alt="ì´ë¯¸ì§€ ${index + 1}">
                        <div class="slot-number">${index + 1}</div>
                        <button class="remove-btn" onclick="removeImage(${index})">Ã—</button>
                    `;
                    generateSubtitleInputs();
                    updateStatus();
                    drawCurrentImage();
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        }

        // ì´ë¯¸ì§€ ì œê±°
        function removeImage(index) {
            images[index] = null;
            subtitles[index] = '';
            const slot = document.querySelectorAll('.upload-slot')[index];
            slot.classList.remove('has-image');
            slot.innerHTML = `
                <input type="file" accept="image/*" onchange="handleImageUpload(${index}, this)">
                <div class="slot-number">${index + 1}</div>
                <div style="font-size: 24px; color: #999;">+</div>
            `;
            generateSubtitleInputs();
            updateStatus();
            drawCurrentImage();
        }

        // ìë§‰ ì…ë ¥ í•„ë“œ ìƒì„±
        function generateSubtitleInputs() {
            const container = document.getElementById('subtitleInputs');
            const validImageIndices = images.map((img, index) => img !== null ? index : -1).filter(index => index !== -1);

            if (validImageIndices.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #666; font-style: italic;">ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•˜ë©´ ìë§‰ì„ ì„¤ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p>';
                return;
            }

            container.innerHTML = validImageIndices.map(index => `
                <div style="background: #fff; padding: 20px; border-radius: 10px; border: 1px solid #ddd;">
                    <label style="display: block; margin-bottom: 10px; font-weight: bold; color: #333;">
                        ì´ë¯¸ì§€ ${index + 1}ë²ˆ ìë§‰:
                    </label>
                    <textarea
                        placeholder="ì´ ì´ë¯¸ì§€ì— í‘œì‹œí•  ìë§‰ì„ ì…ë ¥í•˜ì„¸ìš”..."
                        style="width: 100%; padding: 10px; border: 2px solid #e9ecef; border-radius: 8px; font-size: 14px; resize: vertical; min-height: 80px;"
                        oninput="updateSubtitle(${index}, this.value)"
                    >${subtitles[index] || ''}</textarea>
                </div>
            `).join('');
        }

        function updateSubtitle(index, value) {
            subtitles[index] = value;
            drawCurrentImage();
        }

        function updateFontSizeDisplay() {
            document.getElementById('fontSizeValue').textContent = document.getElementById('subtitleFontSize').value + 'px';
        }

        // ìº”ë²„ìŠ¤ì— í˜„ì¬ ì´ë¯¸ì§€ ê·¸ë¦¬ê¸°
        function drawCurrentImage() {
            const canvas = document.getElementById('videoCanvas');
            const ctx = canvas.getContext('2d');
            const validImages = images.filter(img => img !== null);

            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (validImages.length === 0) {
                ctx.fillStyle = '#999';
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”', canvas.width/2, canvas.height/2);
                return;
            }

            const img = validImages[currentImageIndex % validImages.length];
            if (!img) return;

            // ì´ë¯¸ì§€ ê·¸ë¦¬ê¸° (cover ë°©ì‹)
            const canvasAspect = canvas.width / canvas.height;
            const imgAspect = img.width / img.height;
            let drawWidth, drawHeight, drawX, drawY;

            if (imgAspect > canvasAspect) {
                drawHeight = canvas.height;
                drawWidth = drawHeight * imgAspect;
                drawX = (canvas.width - drawWidth) / 2;
                drawY = 0;
            } else {
                drawWidth = canvas.width;
                drawHeight = drawWidth / imgAspect;
                drawX = 0;
                drawY = (canvas.height - drawHeight) / 2;
            }

            ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);

            // ìë§‰ ê·¸ë¦¬ê¸°
            const validImageIndices = images.map((img, index) => img !== null ? index : -1).filter(index => index !== -1);
            if (validImageIndices.length === 0) return;

            const actualImageIndex = validImageIndices[currentImageIndex % validImageIndices.length];
            const text = subtitles[actualImageIndex];
            if (!text || text.trim() === '') return;

            const fontSize = parseInt(document.getElementById('subtitleFontSize').value);
            const fontColor = document.getElementById('subtitleColor').value;

            ctx.font = 'bold ' + fontSize + 'px "Malgun Gothic", "ë§‘ì€ ê³ ë”•", sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            const maxWidth = canvas.width * 0.9;
            const words = text.split(' ');
            const lines = [];
            let currentLine = words[0] || '';

            for (let i = 1; i < words.length; i++) {
                const word = words[i];
                const width = ctx.measureText(currentLine + " " + word).width;
                if (width < maxWidth) {
                    currentLine += " " + word;
                } else {
                    lines.push(currentLine);
                    currentLine = word;
                }
            }
            if (currentLine) lines.push(currentLine);

            const lineHeight = fontSize * 1.2;
            const startY = canvas.height - 100;

            lines.forEach((line, index) => {
                const x = canvas.width / 2;
                const y = startY + (index * lineHeight);

                // ë°°ê²½
                const textWidth = ctx.measureText(line).width;
                const padding = 20;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(x - textWidth / 2 - padding, y - fontSize / 2 - padding / 2, textWidth + padding * 2, fontSize + padding);

                // í…ìŠ¤íŠ¸
                ctx.fillStyle = fontColor;
                ctx.fillText(line, x, y);
            });
        }

        // FFmpegìœ¼ë¡œ ì˜ìƒ ì œì‘
        async function startRecording() {
            const validImages = images.filter(img => img !== null);

            if (validImages.length === 0) {
                updateStatus('ë¨¼ì € ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”!');
                return;
            }

            if (!ffmpegLoaded || !ffmpeg) {
                updateStatus('âŒ FFmpegì´ ë¡œë”©ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. í˜ì´ì§€ë¥¼ ìƒˆë¡œê³ ì¹¨í•´ì£¼ì„¸ìš”.');
                return;
            }

            try {
                document.getElementById('recordBtn').disabled = true;
                document.getElementById('stopBtn').disabled = false;
                isRecording = true;

                const canvas = document.getElementById('videoCanvas');
                const duration = parseFloat(document.getElementById('imageDuration').value);
                const fps = 30;

                updateStatus('í”„ë ˆì„ ìº¡ì²˜ ì‹œì‘...');

                const fetchFile = window.fetchFile;
                let frameNumber = 0;

                // ëª¨ë“  ì´ë¯¸ì§€ì˜ í”„ë ˆì„ ìƒì„±
                for (let i = 0; i < validImages.length; i++) {
                    currentImageIndex = i;
                    drawCurrentImage();

                    const framesForThisImage = Math.round(duration * fps);

                    for (let f = 0; f < framesForThisImage; f++) {
                        const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
                        const fileName = 'frame' + String(frameNumber).padStart(6, '0') + '.png';
                        ffmpeg.FS('writeFile', fileName, await fetchFile(blob));
                        frameNumber++;
                    }

                    updateProgressBar(i + 1, validImages.length);
                    updateStatus('í”„ë ˆì„ ìº¡ì²˜ ì¤‘... (' + (i + 1) + '/' + validImages.length + ')');
                }

                updateStatus('FFmpegìœ¼ë¡œ ì˜ìƒ ì¸ì½”ë”© ì¤‘...');

                // FFmpegìœ¼ë¡œ ì˜ìƒ ìƒì„±
                const videoBitrate = document.getElementById('videoQuality').value;
                const bitrateK = Math.round(parseInt(videoBitrate) / 1000) + 'k';

                await ffmpeg.run(
                    '-framerate', String(fps),
                    '-start_number', '0',
                    '-i', 'frame%06d.png',
                    '-frames:v', String(frameNumber),
                    '-c:v', 'libx264',
                    '-b:v', bitrateK,
                    '-pix_fmt', 'yuv420p',
                    '-movflags', '+faststart',
                    'output.mp4'
                );

                // ê²°ê³¼ ë‹¤ìš´ë¡œë“œ
                const data = ffmpeg.FS('readFile', 'output.mp4');
                const blob = new Blob([data.buffer], { type: 'video/mp4' });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                const totalDuration = (duration * validImages.length).toFixed(1);
                a.download = 'video-ffmpeg-' + totalDuration + 's-' + Date.now() + '.mp4';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                // ì„ì‹œ íŒŒì¼ ì •ë¦¬
                for (let i = 0; i < frameNumber; i++) {
                    const fileName = 'frame' + String(i).padStart(6, '0') + '.png';
                    try { ffmpeg.FS('unlink', fileName); } catch (e) {}
                }
                try { ffmpeg.FS('unlink', 'output.mp4'); } catch (e) {}

                updateStatus('âœ… FFmpeg ì˜ìƒ ì œì‘ ì™„ë£Œ! (ì´ ' + totalDuration + 'ì´ˆ, ' + frameNumber + ' í”„ë ˆì„)');
                updateProgressBar(0, 1);
                document.getElementById('recordBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
                isRecording = false;

            } catch (error) {
                console.error('FFmpeg ë…¹í™” ì˜¤ë¥˜:', error);
                updateStatus('âŒ FFmpeg ì˜¤ë¥˜: ' + error.message);
                document.getElementById('recordBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
                isRecording = false;
            }
        }

        function stopRecording() {
            isRecording = false;
            document.getElementById('recordBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            updateProgressBar(0, 1);
            updateStatus('ë…¹í™”ê°€ ì¤‘ì§€ë˜ì—ˆìŠµë‹ˆë‹¤.');
        }

        function updateProgressBar(current, total) {
            document.getElementById('progressFill').style.width = (total > 0 ? (current / total) * 100 : 0) + '%';
        }

        function updateStatus(message) {
            const validImages = images.filter(img => img !== null);
            let defaultMessage = 'FFmpeg ì¤€ë¹„ ì™„ë£Œ! ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•˜ê³  ì˜ìƒì„ ì œì‘í•´ë³´ì„¸ìš”!';
            if (validImages.length > 0) {
                defaultMessage = validImages.length + 'ê°œ ì´ë¯¸ì§€ ì—…ë¡œë“œë¨. ì˜ìƒì„ ì œì‘í•´ë³´ì„¸ìš”!';
            }
            document.getElementById('status').textContent = message || defaultMessage;
        }
    </script>
</body>
</html>
