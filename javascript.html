<script>
    // ì „ì—­ ë³€ìˆ˜
    const MAX_IMAGES = 50;
    const MAX_ENDING_IMAGES = 10;
    let images = new Array(MAX_IMAGES).fill(null);
    let subtitles = new Array(MAX_IMAGES).fill('');
    let endingImages = new Array(MAX_ENDING_IMAGES).fill(null);
    let endingSubtitles = new Array(MAX_ENDING_IMAGES).fill('');
    let currentImageIndex = 0;
    let previewInterval = null;
    let mediaRecorder = null;
    let recordedChunks = [];
    let isRecording = false;
    let customMusicFile = null;
    let bgmAudio = null;

    // FFmpeg.wasm ë³€ìˆ˜
    let ffmpeg = null;
    let ffmpegLoaded = false;

    // ì´ˆê¸°í™”
    document.addEventListener('DOMContentLoaded', () => {
        initializeUploadSlots();
        initializeEndingUploadSlots();
        updateCanvasSize();
        updateOpacityDisplay();
        updateVolumeDisplay();
        updatePositionDisplay();
        updateFontSizeDisplay();
        drawCurrentImage();
        loadFFmpeg(); // FFmpeg ì´ˆê¸°í™”
    });

    // FFmpeg.wasm ì´ˆê¸°í™”
    async function loadFFmpeg() {
        try {
            const { createFFmpeg, fetchFile } = FFmpeg;
            ffmpeg = createFFmpeg({
                log: true,
                corePath: 'https://cdn.jsdelivr.net/npm/@ffmpeg/core@0.11.0/dist/ffmpeg-core.js'
            });

            ffmpeg.setProgress(({ ratio }) => {
                if (ratio > 0 && ratio < 1) {
                    const percent = Math.round(ratio * 100);
                    updateStatus('FFmpeg ì¸ì½”ë”© ì¤‘... ' + percent + '%');
                }
            });

            updateStatus('FFmpeg ë¡œë”© ì¤‘... (ìµœì´ˆ 1íšŒë§Œ 30ì´ˆ ì†Œìš”)');
            await ffmpeg.load();
            ffmpegLoaded = true;
            window.fetchFile = fetchFile; // ì „ì—­ìœ¼ë¡œ ì €ì¥
            updateStatus('FFmpeg ë¡œë”© ì™„ë£Œ! ì´ì œ ì˜ìƒì„ ì œì‘í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
            console.log('FFmpeg.wasm loaded successfully');
        } catch (error) {
            console.error('FFmpeg ë¡œë”© ì‹¤íŒ¨:', error);
            updateStatus('âš ï¸ FFmpeg ë¡œë”© ì‹¤íŒ¨. ê¸°ë³¸ ë°©ì‹ìœ¼ë¡œ ì‘ë™í•©ë‹ˆë‹¤.');
            ffmpegLoaded = false;
        }
    }

    // ë“œë˜ê·¸ì•¤ë“œë¡­ ê´€ë ¨ ë³€ìˆ˜
    let draggedSlotIndex = null;

    // ìŠ¬ë¡¯ HTML ìƒì„± (ì¬ì‚¬ìš©)
    function createSlotHTML(index) {
        return `
            <input type="file" accept="image/*" onchange="handleImageUpload(${index}, this)">
            <div class="slot-number">${index + 1}</div>
            <div style="font-size: 24px; color: #999;">+</div>
        `;
    }

    // ì—…ë¡œë“œ ìŠ¬ë¡¯ ì´ˆê¸°í™”
    function initializeUploadSlots() {
        const uploadGrid = document.getElementById('uploadGrid');
        uploadGrid.innerHTML = '';
        for (let i = 0; i < MAX_IMAGES; i++) {
            const slot = document.createElement('div');
            slot.className = 'upload-slot';
            slot.dataset.index = i;
            slot.innerHTML = createSlotHTML(i);
            
            // ëª¨ë“  ìŠ¬ë¡¯ì— ë“œë¡­ ì´ë²¤íŠ¸ ì¶”ê°€ (ë¹ˆ ìŠ¬ë¡¯ë„ ë“œë¡­ ê°€ëŠ¥)
            slot.addEventListener('dragover', handleDragOver);
            slot.addEventListener('drop', handleDrop);
            slot.addEventListener('dragenter', handleDragEnter);
            slot.addEventListener('dragleave', handleDragLeave);
            
            // ì´ë¯¸ì§€ê°€ ìˆëŠ” ìŠ¬ë¡¯ë§Œ ë“œë˜ê·¸ ê°€ëŠ¥
            if (images[i] !== null) {
                slot.draggable = true;
                slot.addEventListener('dragstart', handleDragStart);
                slot.addEventListener('dragend', handleDragEnd);
            }
            
            uploadGrid.appendChild(slot);
        }
    }

    // ë“œë˜ê·¸ ì‹œì‘
    function handleDragStart(e) {
        draggedSlotIndex = parseInt(this.dataset.index);
        this.classList.add('dragging');
        e.dataTransfer.effectAllowed = 'move';
    }

    function handleDragOver(e) {
        if (e.preventDefault) e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
        return false;
    }

    function handleDragEnter(e) {
        if (this !== e.target && this.classList.contains('upload-slot')) {
            this.classList.add('drag-over');
        }
    }

    function handleDragLeave(e) {
        if (this !== e.target && this.classList.contains('upload-slot')) {
            this.classList.remove('drag-over');
        }
    }

    function handleDrop(e) {
        if (e.stopPropagation) e.stopPropagation();
        this.classList.remove('drag-over');
        
        const targetSlotIndex = parseInt(this.dataset.index);
        if (draggedSlotIndex === null || draggedSlotIndex === targetSlotIndex) {
            return false;
        }
        
        // ë“œë˜ê·¸í•œ ì´ë¯¸ì§€ì™€ ìë§‰ ì„ì‹œ ì €ì¥
        const draggedImage = images[draggedSlotIndex];
        const draggedSubtitle = subtitles[draggedSlotIndex];
        
        if (!draggedImage) return false; // ì´ë¯¸ì§€ê°€ ì—†ìœ¼ë©´ ë¬´ì‹œ
        
        // ì‚½ì… ë°©ì‹ìœ¼ë¡œ ìˆœì„œ ë³€ê²½
        if (draggedSlotIndex < targetSlotIndex) {
            // ì•ì—ì„œ ë’¤ë¡œ ì´ë™: ì‚¬ì´ í•­ëª©ë“¤ì„ í•œ ì¹¸ì”© ì•ìœ¼ë¡œ ì´ë™
            for (let i = draggedSlotIndex; i < targetSlotIndex; i++) {
                images[i] = images[i + 1];
                subtitles[i] = subtitles[i + 1];
            }
            images[targetSlotIndex] = draggedImage;
            subtitles[targetSlotIndex] = draggedSubtitle;
        } else {
            // ë’¤ì—ì„œ ì•ìœ¼ë¡œ ì´ë™: ì‚¬ì´ í•­ëª©ë“¤ì„ í•œ ì¹¸ì”© ë’¤ë¡œ ì´ë™
            for (let i = draggedSlotIndex; i > targetSlotIndex; i--) {
                images[i] = images[i - 1];
                subtitles[i] = subtitles[i - 1];
            }
            images[targetSlotIndex] = draggedImage;
            subtitles[targetSlotIndex] = draggedSubtitle;
        }
        
        // UI ì—…ë°ì´íŠ¸ (ë³€ê²½ëœ ë²”ìœ„ë§Œ)
        const startIndex = Math.min(draggedSlotIndex, targetSlotIndex);
        const endIndex = Math.max(draggedSlotIndex, targetSlotIndex);
        const uploadGrid = document.getElementById('uploadGrid');
        
        for (let i = startIndex; i <= endIndex; i++) {
            const slot = uploadGrid.children[i];
            updateSlotDisplay(slot, i);
        }
        
        // í˜„ì¬ ì´ë¯¸ì§€ ì¸ë±ìŠ¤ ì—…ë°ì´íŠ¸
        const validImages = images.filter(img => img !== null);
        if (validImages.length > 0 && currentImageIndex < validImages.length) {
            const oldCurrentImage = validImages[currentImageIndex];
            if (oldCurrentImage) {
                const newValidIndex = validImages.indexOf(oldCurrentImage);
                if (newValidIndex !== -1) {
                    currentImageIndex = newValidIndex;
                }
            }
        }
        
        generateSubtitleInputs();
        drawCurrentImage();
        updateStatus('âœ… ì´ë¯¸ì§€ ìˆœì„œê°€ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤!');
        return false;
    }

    function handleDragEnd(e) {
        this.classList.remove('dragging');
        document.querySelectorAll('.upload-slot').forEach(slot => {
            slot.classList.remove('drag-over');
        });
        draggedSlotIndex = null;
    }

    // ìŠ¬ë¡¯ í‘œì‹œ ì—…ë°ì´íŠ¸
    function updateSlotDisplay(slot, index) {
        slot.dataset.index = index;
        
        if (images[index] !== null) {
            slot.classList.add('has-image');
            slot.innerHTML = `
                <input type="file" accept="image/*" onchange="handleImageUpload(${index}, this)">
                <img src="${images[index].src}" alt="ì´ë¯¸ì§€ ${index + 1}">
                <div class="slot-number">${index + 1}</div>
                <button class="remove-btn" onclick="removeImage(${index})">Ã—</button>
            `;
            slot.draggable = true;
            // ë“œë˜ê·¸ ì´ë²¤íŠ¸ë§Œ ì¶”ê°€ (ë“œë¡­ ì´ë²¤íŠ¸ëŠ” ì´ë¯¸ ìˆìŒ)
            if (!slot.hasAttribute('data-drag-listener')) {
                slot.addEventListener('dragstart', handleDragStart);
                slot.addEventListener('dragend', handleDragEnd);
                slot.setAttribute('data-drag-listener', 'true');
            }
        } else {
            slot.classList.remove('has-image');
            slot.innerHTML = createSlotHTML(index);
            slot.draggable = false;
            slot.removeAttribute('data-drag-listener');
        }
    }

    // ìº”ë²„ìŠ¤ ì´ˆê¸°í™” (ì¬ì‚¬ìš©)
    function resetCanvas() {
        const canvas = document.getElementById('videoCanvas');
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#f8f9fa';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#999';
        ctx.font = '24px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”', canvas.width/2, canvas.height/2);
    }

    // ì´ë¯¸ì§€ë§Œ ì§€ìš°ê¸°
    function clearAllImages() {
        for (let i = 0; i < MAX_IMAGES; i++) {
            images[i] = null;
        }
        initializeUploadSlots();
        resetCanvas();
        stopPreview();
        currentImageIndex = 0;
        document.getElementById('subtitleInputs').innerHTML = '<p style="text-align: center; color: #666; font-style: italic;">ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•˜ë©´ ê° ì´ë¯¸ì§€ë³„ ìë§‰ì„ ì„¤ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. (ê¸°ì¡´ ìë§‰ì€ ìœ ì§€ë©ë‹ˆë‹¤)</p>';
        updateStatus('ëª¨ë“  ì´ë¯¸ì§€ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤! (ìë§‰ì€ ìœ ì§€ë¨)');
    }

    // ê³µí†µ ìë§‰ ì ìš©
    function applyCommonSubtitle() {
        const commonText = document.getElementById('commonSubtitle').value.trim();
        if (!commonText) {
            updateStatus('ê³µí†µ ìë§‰ ë‚´ìš©ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.');
            return;
        }
        
        const validImages = images.filter(img => img !== null);
        if (validImages.length === 0) {
            updateStatus('ë¨¼ì € ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”.');
            return;
        }
        
        for (let i = 0; i < MAX_IMAGES; i++) {
            if (images[i] !== null) {
                subtitles[i] = commonText;
            }
        }
        
        generateSubtitleInputs();
        drawCurrentImage();
        updateStatus(validImages.length + 'ê°œ ì´ë¯¸ì§€ì— ê³µí†µ ìë§‰ì´ ì ìš©ë˜ì—ˆìŠµë‹ˆë‹¤.');
    }

    function clearCommonSubtitle() {
        document.getElementById('commonSubtitle').value = '';
    }

    function clearAllSubtitles() {
        for (let i = 0; i < MAX_IMAGES; i++) {
            subtitles[i] = '';
        }
        generateSubtitleInputs();
        drawCurrentImage();
        updateStatus('ëª¨ë“  ìë§‰ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤!');
    }

    // ì´ë¯¸ì§€ì™€ ìë§‰ ëª¨ë‘ ì§€ìš°ê¸°
    function forceDeleteAllImages() {
        for (let i = 0; i < MAX_IMAGES; i++) {
            images[i] = null;
            subtitles[i] = '';
        }
        initializeUploadSlots();
        document.getElementById('subtitleInputs').innerHTML = '<p style="text-align: center; color: #666; font-style: italic;">ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•˜ë©´ ê° ì´ë¯¸ì§€ë³„ ìë§‰ì„ ì„¤ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p>';
        resetCanvas();
        stopPreview();
        currentImageIndex = 0;
        updateStatus('ëª¨ë“  ì´ë¯¸ì§€ì™€ ìë§‰ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤!');
    }

    function updateFontSizeDisplay() {
        document.getElementById('fontSizeValue').textContent = document.getElementById('subtitleFontSize').value + 'px';
    }

    // ì¼ê´„ ì—…ë¡œë“œ ì²˜ë¦¬
    function processBulkUpload() {
        const bulkInput = document.getElementById('bulkUpload');
        const files = Array.from(bulkInput.files);
        if (files.length === 0) return;

        const emptySlots = [];
        for (let i = 0; i < MAX_IMAGES; i++) {
            if (images[i] === null) emptySlots.push(i);
        }

        if (emptySlots.length === 0) {
            updateStatus('ëª¨ë“  ìŠ¬ë¡¯ì´ ê°€ë“ ì°¼ìŠµë‹ˆë‹¤!');
            bulkInput.value = '';
            return;
        }

        const uploadCount = Math.min(files.length, emptySlots.length);
        let completedUploads = 0;

        files.slice(0, uploadCount).forEach((file, fileIndex) => {
            const slotIndex = emptySlots[fileIndex];
            const reader = new FileReader();
            
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    images[slotIndex] = img;
                    const slot = document.querySelectorAll('.upload-slot')[slotIndex];
                    slot.dataset.index = slotIndex;
                    slot.classList.add('has-image');
                    slot.innerHTML = `
                        <input type="file" accept="image/*" onchange="handleImageUpload(${slotIndex}, this)">
                        <img src="${event.target.result}" alt="ì´ë¯¸ì§€ ${slotIndex + 1}">
                        <div class="slot-number">${slotIndex + 1}</div>
                        <button class="remove-btn" onclick="removeImage(${slotIndex})">Ã—</button>
                    `;
                    // ë“œë˜ê·¸ ê°€ëŠ¥í•˜ê²Œ ì„¤ì •
                    slot.draggable = true;
                    slot.addEventListener('dragstart', handleDragStart);
                    slot.addEventListener('dragover', handleDragOver);
                    slot.addEventListener('drop', handleDrop);
                    slot.addEventListener('dragend', handleDragEnd);
                    slot.addEventListener('dragenter', handleDragEnter);
                    slot.addEventListener('dragleave', handleDragLeave);
                    
                    completedUploads++;
                    if (completedUploads === uploadCount) {
                        generateSubtitleInputs();
                        updateStatus();
                        bulkInput.value = '';
                        drawCurrentImage();
                    }
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        });

        if (files.length > emptySlots.length) {
            updateStatus(emptySlots.length + 'ê°œ ìŠ¬ë¡¯ë§Œ ì‚¬ìš© ê°€ëŠ¥í•˜ì—¬ ' + uploadCount + 'ê°œ ì´ë¯¸ì§€ë§Œ ì—…ë¡œë“œë©ë‹ˆë‹¤.');
        }
    }

    // ì´ë¯¸ì§€ ì—…ë¡œë“œ ì²˜ë¦¬
    function handleImageUpload(index, input) {
        const file = input.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (event) => {
            const img = new Image();
            img.onload = () => {
                images[index] = img;
                const slot = input.parentElement;
                slot.dataset.index = index;
                slot.classList.add('has-image');
                slot.innerHTML = `
                    <input type="file" accept="image/*" onchange="handleImageUpload(${index}, this)">
                    <img src="${event.target.result}" alt="ì´ë¯¸ì§€ ${index + 1}">
                    <div class="slot-number">${index + 1}</div>
                    <button class="remove-btn" onclick="removeImage(${index})">Ã—</button>
                `;
                // ë“œë˜ê·¸ ê°€ëŠ¥í•˜ê²Œ ì„¤ì •
                slot.draggable = true;
                slot.addEventListener('dragstart', handleDragStart);
                slot.addEventListener('dragover', handleDragOver);
                slot.addEventListener('drop', handleDrop);
                slot.addEventListener('dragend', handleDragEnd);
                slot.addEventListener('dragenter', handleDragEnter);
                slot.addEventListener('dragleave', handleDragLeave);
                
                generateSubtitleInputs();
                updateStatus();
                drawCurrentImage();
            };
            img.src = event.target.result;
        };
        reader.readAsDataURL(file);
    }

    // ì´ë¯¸ì§€ ì œê±°
    function removeImage(index) {
        images[index] = null;
        subtitles[index] = '';
        const slot = document.querySelectorAll('.upload-slot')[index];
        slot.classList.remove('has-image');
        slot.innerHTML = createSlotHTML(index);
        slot.draggable = false;
        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì œê±°
        slot.removeEventListener('dragstart', handleDragStart);
        slot.removeEventListener('dragover', handleDragOver);
        slot.removeEventListener('drop', handleDrop);
        slot.removeEventListener('dragend', handleDragEnd);
        slot.removeEventListener('dragenter', handleDragEnter);
        slot.removeEventListener('dragleave', handleDragLeave);
        generateSubtitleInputs();
        updateStatus();
        drawCurrentImage();
    }

    // ìë§‰ ì…ë ¥ í•„ë“œ ìƒì„±
    function generateSubtitleInputs() {
        const container = document.getElementById('subtitleInputs');
        const validImageIndices = images.map((img, index) => img !== null ? index : -1).filter(index => index !== -1);
        
        if (validImageIndices.length === 0) {
            container.innerHTML = '<p style="text-align: center; color: #666; font-style: italic;">ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•˜ë©´ ê° ì´ë¯¸ì§€ë³„ ìë§‰ì„ ì„¤ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p>';
            return;
        }
        
        container.innerHTML = validImageIndices.map(index => `
            <div style="background: #fff; padding: 20px; border-radius: 10px; border: 1px solid #ddd;">
                <label style="display: block; margin-bottom: 10px; font-weight: bold; color: #333;">
                    ì´ë¯¸ì§€ ${index + 1}ë²ˆ ìë§‰:
                </label>
                <textarea 
                    placeholder="ì´ ì´ë¯¸ì§€ì— í‘œì‹œí•  ìë§‰ì„ ì…ë ¥í•˜ì„¸ìš”..."
                    style="width: 100%; padding: 10px; border: 2px solid #e9ecef; border-radius: 8px; font-size: 14px; resize: vertical; min-height: 80px;"
                    oninput="updateSubtitle(${index}, this.value)"
                >${subtitles[index] || ''}</textarea>
            </div>
        `).join('');
    }

    function updateSubtitle(index, value) {
        subtitles[index] = value;
        previewSubtitle();
    }

    // ì—”ë”© ìë§‰ ì…ë ¥ í•„ë“œ ìƒì„±
    function generateEndingSubtitleInputs() {
        const container = document.getElementById('endingSubtitleInputs');
        const validEndingIndices = endingImages.map((img, index) => img !== null ? index : -1).filter(index => index !== -1);

        if (validEndingIndices.length === 0) {
            container.innerHTML = '<p style="text-align: center; color: #666; font-style: italic;">ì—”ë”© ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•˜ë©´ ê° ì´ë¯¸ì§€ë³„ ìë§‰ì„ ì„¤ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p>';
            return;
        }

        container.innerHTML = validEndingIndices.map(index => `
            <div style="background: #fff3cd; padding: 20px; border-radius: 10px; border: 1px solid #ffc107;">
                <label style="display: block; margin-bottom: 10px; font-weight: bold; color: #856404;">
                    ì—”ë”© ì´ë¯¸ì§€ E${index + 1}ë²ˆ ìë§‰:
                </label>
                <textarea
                    placeholder="ì´ ì—”ë”© ì´ë¯¸ì§€ì— í‘œì‹œí•  ìë§‰ì„ ì…ë ¥í•˜ì„¸ìš”..."
                    style="width: 100%; padding: 10px; border: 2px solid #ffc107; border-radius: 8px; font-size: 14px; resize: vertical; min-height: 80px;"
                    oninput="updateEndingSubtitle(${index}, this.value)"
                >${endingSubtitles[index] || ''}</textarea>
            </div>
        `).join('');
    }

    function updateEndingSubtitle(index, value) {
        endingSubtitles[index] = value;
    }

    function previewSubtitle() {
        document.getElementById('customPositionGroup').style.display = 
            document.getElementById('subtitlePosition').value === 'custom' ? 'block' : 'none';
        drawCurrentImage();
    }

    function updateOpacityDisplay() {
        document.getElementById('opacityValue').textContent = 
            Math.round(document.getElementById('subtitleOpacity').value * 100) + '%';
    }

    function updatePositionDisplay() {
        document.getElementById('positionValue').textContent = 
            document.getElementById('subtitleVerticalPosition').value + '%';
    }

    function updateVolumeDisplay() {
        document.getElementById('volumeValue').textContent =
            Math.round(document.getElementById('bgmVolume').value * 100) + '%';
    }

    function updateBGMRangeDisplay() {
        const startTime = parseFloat(document.getElementById('bgmStartTime').value);
        const endTime = parseFloat(document.getElementById('bgmEndTime').value);

        document.getElementById('bgmStartDisplay').textContent = startTime.toFixed(1);
        document.getElementById('bgmEndDisplay').textContent = endTime.toFixed(1);

        if (endTime > startTime) {
            document.getElementById('bgmDurationDisplay').textContent = (endTime - startTime).toFixed(1);
        } else {
            document.getElementById('bgmDurationDisplay').textContent = 'ì „ì²´';
        }
    }

    function handleBGMTypeChange() {
        const customSection = document.getElementById('customMusicSection');
        const timingSection = document.getElementById('bgmTimingSection');
        const isCustom = document.getElementById('bgmType').value === 'custom';
        customSection.style.display = isCustom ? 'block' : 'none';
        timingSection.style.display = isCustom ? 'block' : 'none';

        if (!isCustom) {
            stopBGM();
            customMusicFile = null;
            document.getElementById('musicInfo').style.display = 'none';
        }
    }

    function handleMusicUpload(input) {
        const file = input.files[0];
        if (!file) return;

        if (!file.name.toLowerCase().endsWith('.mp3')) {
            updateStatus('MP3 íŒŒì¼ë§Œ ì§€ì›ë©ë‹ˆë‹¤!');
            input.value = '';
            return;
        }

        if (file.size > 10 * 1024 * 1024) {
            updateStatus('íŒŒì¼ í¬ê¸°ê°€ ë„ˆë¬´ í½ë‹ˆë‹¤. 10MB ì´í•˜ì˜ íŒŒì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”.');
            input.value = '';
            return;
        }

        customMusicFile = file;
        document.getElementById('musicName').textContent = 'ğŸµ ' + file.name;
        document.getElementById('musicSize').textContent = 'ğŸ“ í¬ê¸°: ' + (file.size / 1024 / 1024).toFixed(1) + 'MB';
        document.getElementById('musicInfo').style.display = 'block';
        updateStatus('MP3 íŒŒì¼ ì—…ë¡œë“œ ì™„ë£Œ: ' + file.name);
    }

    function previewBGM() {
        const bgmType = document.getElementById('bgmType').value;
        const volume = parseFloat(document.getElementById('bgmVolume').value);
        
        if (bgmType === 'none') {
            updateStatus('BGMì„ ì„ íƒí•´ì£¼ì„¸ìš”!');
            return;
        }

        stopBGM();

        if (bgmType === 'custom') {
            if (!customMusicFile) {
                updateStatus('ë¨¼ì € MP3 íŒŒì¼ì„ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”!');
                return;
            }

            try {
                const startTime = parseFloat(document.getElementById('bgmStartTime').value) || 0;
                const endTime = parseFloat(document.getElementById('bgmEndTime').value) || 0;

                bgmAudio = new Audio();
                bgmAudio.src = URL.createObjectURL(customMusicFile);
                bgmAudio.volume = volume;
                bgmAudio.loop = false;
                bgmAudio.currentTime = startTime;

                bgmAudio.addEventListener('loadeddata', () => {
                    const duration = endTime > startTime ? endTime - startTime : bgmAudio.duration;
                    updateStatus('ì»¤ìŠ¤í…€ MP3 ë¯¸ë¦¬ë“£ê¸° ì¤‘... (' + duration.toFixed(1) + 'ì´ˆ)');
                    bgmAudio.play();

                    // ì¢…ë£Œ ì‹œì  ì²´í¬
                    if (endTime > startTime) {
                        const checkInterval = setInterval(() => {
                            if (bgmAudio && bgmAudio.currentTime >= endTime) {
                                clearInterval(checkInterval);
                                stopBGM();
                                updateStatus();
                            }
                        }, 100);
                        bgmAudio.dataset.checkInterval = checkInterval;
                    } else {
                        // êµ¬ê°„ ì„¤ì •ì´ ì—†ìœ¼ë©´ ëê¹Œì§€ ì¬ìƒ
                        bgmAudio.addEventListener('ended', () => {
                            stopBGM();
                            updateStatus();
                        }, { once: true });
                    }
                });

                bgmAudio.addEventListener('error', () => {
                    updateStatus('MP3 íŒŒì¼ì„ ì¬ìƒí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                    stopBGM();
                });
            } catch (error) {
                updateStatus('ì»¤ìŠ¤í…€ ìŒì•… ì¬ìƒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
            }
        } else {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const masterGain = audioContext.createGain();
                masterGain.gain.value = volume * 0.15;
                masterGain.connect(audioContext.destination);

                const oscillators = [];

                if (bgmType === 'peaceful') {
                    // ì°¨ë¶„í•œ ìŒì•…: C major ì½”ë“œ (C, E, G)
                    [261.63, 329.63, 392.00].forEach((freq, i) => {
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        osc.type = 'sine';
                        osc.frequency.value = freq;
                        gain.gain.value = 0.3 - (i * 0.05);
                        osc.connect(gain);
                        gain.connect(masterGain);
                        osc.start();
                        oscillators.push(osc);
                    });
                } else if (bgmType === 'upbeat') {
                    // í™œê¸°ì°¬ ìŒì•…: G major ì½”ë“œ + ë¦¬ë“¬
                    [392.00, 493.88, 587.33].forEach((freq, i) => {
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        osc.type = 'triangle';
                        osc.frequency.value = freq;
                        gain.gain.value = 0.25;

                        // ë¦¬ë“¬ê° ì¶”ê°€
                        gain.gain.setValueAtTime(0.25, audioContext.currentTime);
                        for (let t = 0; t < 5; t += 0.5) {
                            gain.gain.setValueAtTime(0.35, audioContext.currentTime + t);
                            gain.gain.setValueAtTime(0.15, audioContext.currentTime + t + 0.25);
                        }

                        osc.connect(gain);
                        gain.connect(masterGain);
                        osc.start();
                        oscillators.push(osc);
                    });
                } else if (bgmType === 'cinematic') {
                    // ì˜í™”ê°™ì€ ìŒì•…: Am ì½”ë“œ (A, C, E) - ë‚®ì€ ìŒì—­
                    [110.00, 130.81, 164.81, 220.00].forEach((freq, i) => {
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        osc.type = 'sawtooth';
                        osc.frequency.value = freq;
                        gain.gain.value = 0.2 - (i * 0.03);

                        // ì ì§„ì  ë³¼ë¥¨ ì¦ê°€ (ì˜í™” ê°™ì€ íš¨ê³¼)
                        gain.gain.setValueAtTime(0, audioContext.currentTime);
                        gain.gain.linearRampToValueAtTime(gain.gain.value, audioContext.currentTime + 1);

                        osc.connect(gain);
                        gain.connect(masterGain);
                        osc.start();
                        oscillators.push(osc);
                    });
                }

                bgmAudio = { oscillators, audioContext };

                const bgmNames = { 'peaceful': 'ì°¨ë¶„í•œ', 'upbeat': 'í™œê¸°ì°¬', 'cinematic': 'ì˜í™”ê°™ì€' };
                updateStatus(bgmNames[bgmType] + ' BGM ë¯¸ë¦¬ë“£ê¸° ì¤‘... (â¹ï¸ ì •ì§€ ë²„íŠ¼ìœ¼ë¡œ ì¤‘ì§€)');
            } catch (error) {
                updateStatus('BGM ì¬ìƒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
            }
        }
    }

    function stopBGMPreview() {
        stopBGM();
        updateStatus();
    }

    function stopBGM() {
        if (bgmAudio) {
            try {
                if (bgmAudio.pause) {
                    // ì»¤ìŠ¤í…€ MP3 íŒŒì¼ ì •ì§€
                    bgmAudio.pause();
                    bgmAudio.currentTime = 0;
                    if (bgmAudio.src && bgmAudio.src.startsWith('blob:')) {
                        URL.revokeObjectURL(bgmAudio.src);
                    }
                } else if (bgmAudio.oscillators) {
                    // ì—¬ëŸ¬ ì˜¤ì‹¤ë ˆì´í„° ì •ì§€
                    bgmAudio.oscillators.forEach(osc => {
                        try { osc.stop(); } catch (e) {}
                    });
                    bgmAudio.audioContext.close();
                } else if (bgmAudio.oscillator) {
                    // ë‹¨ì¼ ì˜¤ì‹¤ë ˆì´í„° ì •ì§€ (í•˜ìœ„ í˜¸í™˜ì„±)
                    bgmAudio.oscillator.stop();
                    bgmAudio.audioContext.close();
                }
            } catch (e) {}
            bgmAudio = null;
        }
    }

    function updateCanvasSize() {
        const [width, height] = document.getElementById('videoSize').value.split(',').map(Number);
        const canvas = document.getElementById('videoCanvas');
        canvas.width = width;
        canvas.height = height;
        
        const maxDisplayWidth = 500;
        const maxDisplayHeight = 400;
        const aspectRatio = width / height;
        
        if (width > height) {
            canvas.style.width = maxDisplayWidth + 'px';
            canvas.style.height = (maxDisplayWidth / aspectRatio) + 'px';
        } else {
            canvas.style.height = maxDisplayHeight + 'px';
            canvas.style.width = (maxDisplayHeight * aspectRatio) + 'px';
        }
        
        const ratios = { '1920,1080': '16:9', '1080,1920': '9:16', '1080,1350': '4:5', '1080,1080': '1:1' };
        document.getElementById('ratioIndicator').textContent = ratios[width + ',' + height] || '';
        
        drawCurrentImage();
    }

    function drawCurrentImage() {
        const canvas = document.getElementById('videoCanvas');
        const ctx = canvas.getContext('2d');
        const validImages = images.filter(img => img !== null);
        
        ctx.fillStyle = document.getElementById('backgroundColor').value;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        if (validImages.length === 0) {
            ctx.fillStyle = '#999';
            ctx.font = '24px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”', canvas.width/2, canvas.height/2);
            return;
        }
        
        const img = validImages[currentImageIndex % validImages.length];
        if (!img) return;
        
        const canvasAspect = canvas.width / canvas.height;
        const imgAspect = img.width / img.height;
        const imageScaling = document.getElementById('imageScaling').value;
        let drawWidth, drawHeight, drawX, drawY;
        
        if (imageScaling === 'contain') {
            if (imgAspect > canvasAspect) {
                drawWidth = canvas.width;
                drawHeight = drawWidth / imgAspect;
                drawX = 0;
                drawY = (canvas.height - drawHeight) / 2;
            } else {
                drawHeight = canvas.height;
                drawWidth = drawHeight * imgAspect;
                drawX = (canvas.width - drawWidth) / 2;
                drawY = 0;
            }
        } else {
            if (imgAspect > canvasAspect) {
                drawHeight = canvas.height;
                drawWidth = drawHeight * imgAspect;
                drawX = (canvas.width - drawWidth) / 2;
                drawY = 0;
            } else {
                drawWidth = canvas.width;
                drawHeight = drawWidth / imgAspect;
                drawX = 0;
                drawY = (canvas.height - drawHeight) / 2;
            }
        }
        
        ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
        drawSubtitle(ctx, currentImageIndex, canvas.width, canvas.height);
    }

    function drawSubtitle(ctx, imageIndex, canvasWidth, canvasHeight) {
        const validImageIndices = images.map((img, index) => img !== null ? index : -1).filter(index => index !== -1);
        if (validImageIndices.length === 0) return;
        
        const actualImageIndex = validImageIndices[imageIndex % validImageIndices.length];
        const text = subtitles[actualImageIndex];
        if (!text || text.trim() === '') return;
        
        const fontSize = parseInt(document.getElementById('subtitleFontSize').value);
        const fontColor = document.getElementById('subtitleColor').value;
        const subtitlePositionType = document.getElementById('subtitlePosition').value;
        const hasBackground = document.getElementById('subtitleBackground').value === 'true';
        const bgColor = document.getElementById('subtitleBgColor').value;
        const opacity = parseFloat(document.getElementById('subtitleOpacity').value);
        
        ctx.font = 'bold ' + fontSize + 'px -apple-system, BlinkMacSystemFont, "Malgun Gothic", "ë§‘ì€ ê³ ë”•", "Segoe UI", Roboto, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        const maxWidth = canvasWidth * 0.9;
        const words = text.split(' ');
        const lines = [];
        let currentLine = words[0] || '';
        
        for (let i = 1; i < words.length; i++) {
            const word = words[i];
            const width = ctx.measureText(currentLine + " " + word).width;
            if (width < maxWidth) {
                currentLine += " " + word;
            } else {
                lines.push(currentLine);
                currentLine = word;
            }
        }
        if (currentLine) lines.push(currentLine);
        
        const lineHeight = fontSize * 1.2;
        const totalHeight = lines.length * lineHeight;
        
        let startY;
        if (subtitlePositionType === 'custom') {
            const customPosition = parseFloat(document.getElementById('subtitleVerticalPosition').value);
            startY = (canvasHeight * customPosition / 100) + (lineHeight / 2);
        } else {
            const positions = {
                'top': totalHeight / 2 + 50,
                'center': canvasHeight / 2 - (totalHeight / 2) + lineHeight / 2,
                'bottom': canvasHeight - totalHeight / 2 - 50
            };
            startY = positions[subtitlePositionType] || positions['bottom'];
        }
        
        lines.forEach((line, index) => {
            const x = canvasWidth / 2;
            const y = startY + (index * lineHeight);
            
            if (hasBackground) {
                const textWidth = ctx.measureText(line).width;
                const padding = 20;
                ctx.fillStyle = bgColor + Math.round(opacity * 255).toString(16).padStart(2, '0');
                ctx.fillRect(x - textWidth / 2 - padding, y - fontSize / 2 - padding / 2, textWidth + padding * 2, fontSize + padding);
            }
            
            ctx.fillStyle = fontColor;
            ctx.fillText(line, x, y);
        });
    }

    async function startPreview() {
        const validImages = images.filter(img => img !== null);
        const validEndingImages = endingImages.filter(img => img !== null);

        if (validImages.length === 0 && validEndingImages.length === 0) {
            updateStatus('ë¨¼ì € ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”!');
            return;
        }

        stopPreview();
        const duration = parseFloat(document.getElementById('imageDuration').value) * 1000;
        const endingDuration = parseFloat(document.getElementById('endingImageDuration')?.value || 3) * 1000;
        const totalFrames = validImages.length + validEndingImages.length;

        updateProgressBar(0, totalFrames);

        // BGM ë¯¸ë¦¬ë³´ê¸° ì¬ìƒ
        startPreviewBGM();

        updateStatus('ë¯¸ë¦¬ë³´ê¸° ì¬ìƒ ì¤‘... (1íšŒ ì¬ìƒ)');

        let processedFrames = 0;

        // ë©”ì¸ ì´ë¯¸ì§€ ì¬ìƒ
        for (let i = 0; i < validImages.length; i++) {
            currentImageIndex = i;
            drawCurrentImage();
            processedFrames++;
            updateProgressBar(processedFrames, totalFrames);

            await new Promise(resolve => {
                previewInterval = setTimeout(resolve, duration);
            });
        }

        // ì—”ë”© ì´ë¯¸ì§€ ì¬ìƒ
        if (validEndingImages.length > 0) {
            const validEndingIndices = endingImages
                .map((img, index) => img !== null ? index : -1)
                .filter(index => index !== -1);

            for (let i = 0; i < validEndingImages.length; i++) {
                const actualIndex = validEndingIndices[i];
                const canvas = document.getElementById('videoCanvas');
                const ctx = canvas.getContext('2d');
                const img = endingImages[actualIndex];

                if (img) {
                    // ì—”ë”© ì´ë¯¸ì§€ ë Œë”ë§ (ë©”ì¸ ì´ë¯¸ì§€ ë Œë”ë§ ë¡œì§ê³¼ ë™ì¼)
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = document.getElementById('backgroundColor').value;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    const canvasAspect = canvas.width / canvas.height;
                    const imgAspect = img.width / img.height;
                    const imageScaling = document.getElementById('imageScaling').value;
                    let drawWidth, drawHeight, drawX, drawY;

                    if (imageScaling === 'contain') {
                        if (imgAspect > canvasAspect) {
                            drawWidth = canvas.width;
                            drawHeight = drawWidth / imgAspect;
                            drawX = 0;
                            drawY = (canvas.height - drawHeight) / 2;
                        } else {
                            drawHeight = canvas.height;
                            drawWidth = drawHeight * imgAspect;
                            drawX = (canvas.width - drawWidth) / 2;
                            drawY = 0;
                        }
                    } else { // cover
                        if (imgAspect > canvasAspect) {
                            drawHeight = canvas.height;
                            drawWidth = drawHeight * imgAspect;
                            drawX = (canvas.width - drawWidth) / 2;
                            drawY = 0;
                        } else {
                            drawWidth = canvas.width;
                            drawHeight = drawWidth / imgAspect;
                            drawX = 0;
                            drawY = (canvas.height - drawHeight) / 2;
                        }
                    }

                    ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);

                    // ì—”ë”© ìë§‰ ê·¸ë¦¬ê¸°
                    const subtitle = endingSubtitles[actualIndex];
                    if (subtitle && subtitle.trim() !== '') {
                        const fontSize = parseInt(document.getElementById('subtitleFontSize').value);
                        const fontColor = document.getElementById('subtitleColor').value;
                        const position = document.getElementById('subtitlePosition').value;
                        const useBackground = document.getElementById('subtitleBackground').value === 'true';
                        const bgColor = document.getElementById('subtitleBgColor').value;
                        const opacity = parseFloat(document.getElementById('subtitleOpacity').value);

                        ctx.font = 'bold ' + fontSize + 'px "Malgun Gothic", "ë§‘ì€ ê³ ë”•", sans-serif';
                        ctx.textAlign = 'center';

                        const lines = subtitle.split('\n');
                        const lineHeight = fontSize * 1.3;

                        let baseY;
                        if (position === 'top') {
                            baseY = canvas.height * 0.15;
                        } else if (position === 'center') {
                            baseY = canvas.height / 2 - ((lines.length - 1) * lineHeight) / 2;
                        } else if (position === 'custom') {
                            const customPos = parseFloat(document.getElementById('subtitleVerticalPosition').value) / 100;
                            baseY = canvas.height * customPos;
                        } else {
                            baseY = canvas.height * 0.85 - ((lines.length - 1) * lineHeight);
                        }

                        lines.forEach((line, index) => {
                            const y = baseY + (index * lineHeight);
                            const metrics = ctx.measureText(line);
                            const textWidth = metrics.width;

                            if (useBackground) {
                                const padding = 20;
                                ctx.fillStyle = bgColor;
                                ctx.globalAlpha = opacity;
                                ctx.fillRect(
                                    canvas.width / 2 - textWidth / 2 - padding,
                                    y - fontSize,
                                    textWidth + padding * 2,
                                    fontSize * 1.3
                                );
                                ctx.globalAlpha = 1.0;
                            }

                            ctx.strokeStyle = '#000000';
                            ctx.lineWidth = fontSize * 0.1;
                            ctx.strokeText(line, canvas.width / 2, y);

                            ctx.fillStyle = fontColor;
                            ctx.fillText(line, canvas.width / 2, y);
                        });
                    }
                }

                processedFrames++;
                updateProgressBar(processedFrames, totalFrames);

                await new Promise(resolve => {
                    previewInterval = setTimeout(resolve, endingDuration);
                });
            }
        }

        stopBGM();
        updateStatus('ë¯¸ë¦¬ë³´ê¸° ì™„ë£Œ!');
        updateProgressBar(0, totalFrames);
    }

    function startPreviewBGM() {
        const bgmType = document.getElementById('bgmType').value;
        const volume = parseFloat(document.getElementById('bgmVolume').value);

        if (bgmType === 'none') return;

        stopBGM();

        if (bgmType === 'custom' && customMusicFile) {
            try {
                const startTime = parseFloat(document.getElementById('bgmStartTime').value) || 0;
                const endTime = parseFloat(document.getElementById('bgmEndTime').value) || 0;

                bgmAudio = new Audio();
                bgmAudio.src = URL.createObjectURL(customMusicFile);
                bgmAudio.volume = volume;
                bgmAudio.loop = true;
                bgmAudio.currentTime = startTime;

                bgmAudio.addEventListener('loadeddata', () => {
                    bgmAudio.play();

                    // ì¢…ë£Œ ì‹œì  ì²´í¬ (ë£¨í”„)
                    if (endTime > startTime) {
                        const checkInterval = setInterval(() => {
                            if (bgmAudio && bgmAudio.currentTime >= endTime) {
                                bgmAudio.currentTime = startTime;
                            }
                        }, 100);
                        bgmAudio.dataset.checkInterval = checkInterval;
                    }
                });
            } catch (error) {
                console.warn('BGM ë¯¸ë¦¬ë³´ê¸° ì‹¤íŒ¨:', error);
            }
        } else if (bgmType !== 'custom' && bgmType !== 'none') {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const masterGain = audioContext.createGain();
                masterGain.gain.value = volume * 0.15;
                masterGain.connect(audioContext.destination);

                const oscillators = [];

                if (bgmType === 'peaceful') {
                    [261.63, 329.63, 392.00].forEach((freq, i) => {
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        osc.type = 'sine';
                        osc.frequency.value = freq;
                        gain.gain.value = 0.3 - (i * 0.05);
                        osc.connect(gain);
                        gain.connect(masterGain);
                        osc.start();
                        oscillators.push(osc);
                    });
                } else if (bgmType === 'upbeat') {
                    [392.00, 493.88, 587.33].forEach((freq, i) => {
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        osc.type = 'triangle';
                        osc.frequency.value = freq;
                        gain.gain.value = 0.25;

                        gain.gain.setValueAtTime(0.25, audioContext.currentTime);
                        for (let t = 0; t < 60; t += 0.5) {
                            gain.gain.setValueAtTime(0.35, audioContext.currentTime + t);
                            gain.gain.setValueAtTime(0.15, audioContext.currentTime + t + 0.25);
                        }

                        osc.connect(gain);
                        gain.connect(masterGain);
                        osc.start();
                        oscillators.push(osc);
                    });
                } else if (bgmType === 'cinematic') {
                    [110.00, 130.81, 164.81, 220.00].forEach((freq, i) => {
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        osc.type = 'sawtooth';
                        osc.frequency.value = freq;
                        gain.gain.value = 0.2 - (i * 0.03);

                        gain.gain.setValueAtTime(0, audioContext.currentTime);
                        gain.gain.linearRampToValueAtTime(gain.gain.value, audioContext.currentTime + 1);

                        osc.connect(gain);
                        gain.connect(masterGain);
                        osc.start();
                        oscillators.push(osc);
                    });
                }

                bgmAudio = { oscillators, audioContext };
            } catch (error) {
                console.warn('BGM ë¯¸ë¦¬ë³´ê¸° ì‹¤íŒ¨:', error);
            }
        }
    }

    function stopPreview() {
        if (previewInterval) {
            clearInterval(previewInterval);
            previewInterval = null;
        }
        stopBGM();
        updateProgressBar(0, 1);
        updateStatus();
    }

    function updateProgressBar(current, total) {
        document.getElementById('progressFill').style.width = (total > 0 ? (current / total) * 100 : 0) + '%';
    }

    async function startRecording() {
        const validImages = images.filter(img => img !== null);
        const validEndingImages = endingImages.filter(img => img !== null);

        if (validImages.length === 0 && validEndingImages.length === 0) {
            updateStatus('ë¨¼ì € ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”!');
            return;
        }

        // FFmpeg ì‚¬ìš© ê°€ëŠ¥ ì—¬ë¶€ í™•ì¸
        if (ffmpegLoaded && ffmpeg) {
            await startRecordingWithFFmpeg();
        } else {
            await startRecordingWithMediaRecorder();
        }
    }

    // FFmpeg.wasmì„ ì‚¬ìš©í•œ ì˜ìƒ ì œì‘
    async function startRecordingWithFFmpeg() {
        const validImages = images.filter(img => img !== null);
        const validEndingImages = endingImages.filter(img => img !== null);
        const totalFrames = validImages.length + validEndingImages.length;

        try {
            stopPreview();
            stopBGM();

            document.getElementById('recordBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            isRecording = true;

            const canvas = document.getElementById('videoCanvas');
            const duration = parseFloat(document.getElementById('imageDuration').value);
            const endingDuration = parseFloat(document.getElementById('endingImageDuration')?.value || 3);
            const fps = 30;
            const bgmType = document.getElementById('bgmType').value;

            updateStatus('í”„ë ˆì„ ìº¡ì²˜ ì‹œì‘...');

            // 1ë‹¨ê³„: ëª¨ë“  í”„ë ˆì„ì„ ì´ë¯¸ì§€ë¡œ ìº¡ì²˜
            const fetchFile = window.fetchFile;
            const validImageIndices = images.map((img, idx) => img !== null ? idx : -1).filter(idx => idx !== -1);
            const validEndingIndices = endingImages.map((img, idx) => img !== null ? idx : -1).filter(idx => idx !== -1);

            let frameNumber = 0;

            // ë©”ì¸ ì´ë¯¸ì§€ í”„ë ˆì„ ìƒì„±
            for (let i = 0; i < validImages.length; i++) {
                currentImageIndex = i;
                drawCurrentImage();

                const framesForThisImage = Math.round(duration * fps);

                for (let f = 0; f < framesForThisImage; f++) {
                    const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
                    const fileName = 'frame' + String(frameNumber).padStart(6, '0') + '.png';
                    ffmpeg.FS('writeFile', fileName, await fetchFile(blob));
                    frameNumber++;
                }

                updateProgressBar(i + 1, totalFrames);
                updateStatus('ë©”ì¸ í”„ë ˆì„ ìº¡ì²˜ ì¤‘... (' + (i + 1) + '/' + validImages.length + ')');
            }

            // ì—”ë”© ì´ë¯¸ì§€ í”„ë ˆì„ ìƒì„±
            for (let i = 0; i < validEndingImages.length; i++) {
                const actualIndex = validEndingIndices[i];
                const img = endingImages[actualIndex];

                if (img) {
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = document.getElementById('backgroundColor').value;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    const canvasAspect = canvas.width / canvas.height;
                    const imgAspect = img.width / img.height;
                    const imageScaling = document.getElementById('imageScaling').value;
                    let drawWidth, drawHeight, drawX, drawY;

                    if (imageScaling === 'contain') {
                        if (imgAspect > canvasAspect) {
                            drawWidth = canvas.width;
                            drawHeight = drawWidth / imgAspect;
                            drawX = 0;
                            drawY = (canvas.height - drawHeight) / 2;
                        } else {
                            drawHeight = canvas.height;
                            drawWidth = drawHeight * imgAspect;
                            drawX = (canvas.width - drawWidth) / 2;
                            drawY = 0;
                        }
                    } else {
                        if (imgAspect > canvasAspect) {
                            drawHeight = canvas.height;
                            drawWidth = drawHeight * imgAspect;
                            drawX = (canvas.width - drawWidth) / 2;
                            drawY = 0;
                        } else {
                            drawWidth = canvas.width;
                            drawHeight = drawWidth / imgAspect;
                            drawX = 0;
                            drawY = (canvas.height - drawHeight) / 2;
                        }
                    }

                    ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);

                    // ì—”ë”© ìë§‰
                    const subtitle = endingSubtitles[actualIndex];
                    if (subtitle && subtitle.trim() !== '') {
                        const fontSize = parseInt(document.getElementById('subtitleFontSize').value);
                        const fontColor = document.getElementById('subtitleColor').value;
                        const position = document.getElementById('subtitlePosition').value;
                        const useBackground = document.getElementById('subtitleBackground').value === 'true';
                        const bgColor = document.getElementById('subtitleBgColor').value;
                        const opacity = parseFloat(document.getElementById('subtitleOpacity').value);

                        ctx.font = 'bold ' + fontSize + 'px "Malgun Gothic", "ë§‘ì€ ê³ ë”•", sans-serif';
                        ctx.textAlign = 'center';

                        const lines = subtitle.split('\n');
                        const lineHeight = fontSize * 1.3;

                        let baseY;
                        if (position === 'top') {
                            baseY = canvas.height * 0.15;
                        } else if (position === 'center') {
                            baseY = canvas.height / 2 - ((lines.length - 1) * lineHeight) / 2;
                        } else if (position === 'custom') {
                            const customPos = parseFloat(document.getElementById('subtitleVerticalPosition').value) / 100;
                            baseY = canvas.height * customPos;
                        } else {
                            baseY = canvas.height * 0.85 - ((lines.length - 1) * lineHeight);
                        }

                        lines.forEach((line, index) => {
                            const y = baseY + (index * lineHeight);
                            const metrics = ctx.measureText(line);
                            const textWidth = metrics.width;

                            if (useBackground) {
                                const padding = 20;
                                ctx.fillStyle = bgColor;
                                ctx.globalAlpha = opacity;
                                ctx.fillRect(
                                    canvas.width / 2 - textWidth / 2 - padding,
                                    y - fontSize,
                                    textWidth + padding * 2,
                                    fontSize * 1.3
                                );
                                ctx.globalAlpha = 1.0;
                            }

                            ctx.strokeStyle = '#000000';
                            ctx.lineWidth = fontSize * 0.1;
                            ctx.strokeText(line, canvas.width / 2, y);

                            ctx.fillStyle = fontColor;
                            ctx.fillText(line, canvas.width / 2, y);
                        });
                    }

                    const framesForThisImage = Math.round(endingDuration * fps);

                    for (let f = 0; f < framesForThisImage; f++) {
                        const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
                        const fileName = 'frame' + String(frameNumber).padStart(6, '0') + '.png';
                        ffmpeg.FS('writeFile', fileName, await fetchFile(blob));
                        frameNumber++;
                    }

                    updateProgressBar(validImages.length + i + 1, totalFrames);
                    updateStatus('ì—”ë”© í”„ë ˆì„ ìº¡ì²˜ ì¤‘... (' + (i + 1) + '/' + validEndingImages.length + ')');
                }
            }

            updateStatus('FFmpegìœ¼ë¡œ ì˜ìƒ ì¸ì½”ë”© ì¤‘...');

            // 2ë‹¨ê³„: FFmpegìœ¼ë¡œ ì˜ìƒ ìƒì„±
            const videoBitrate = document.getElementById('videoQuality').value;
            const bitrateK = Math.round(parseInt(videoBitrate) / 1000) + 'k';

            // BGM ì¶”ê°€ (FFmpeg ì‹¤í–‰ ì „ì— íŒŒì¼ ì¤€ë¹„)
            if (bgmType === 'custom' && customMusicFile) {
                ffmpeg.FS('writeFile', 'bgm.mp3', await fetchFile(customMusicFile));
            }

            // FFmpeg ëª…ë ¹ì–´ êµ¬ì„±
            const ffmpegArgs = [
                '-framerate', String(fps),
                '-start_number', '0',
                '-i', 'frame%06d.png',
                '-frames:v', String(frameNumber),
                '-c:v', 'libx264',
                '-b:v', bitrateK,
                '-pix_fmt', 'yuv420p',
                '-movflags', '+faststart'
            ];

            // BGM ì˜µì…˜ ì¶”ê°€
            if (bgmType === 'custom' && customMusicFile) {
                const volume = parseFloat(document.getElementById('bgmVolume').value);
                const startTime = parseFloat(document.getElementById('bgmStartTime').value) || 0;
                const endTime = parseFloat(document.getElementById('bgmEndTime').value) || 0;

                if (endTime > startTime) {
                    ffmpegArgs.splice(0, 0, '-ss', String(startTime), '-to', String(endTime));
                }

                ffmpegArgs.push(
                    '-i', 'bgm.mp3',
                    '-filter_complex', '[1:a]volume=' + volume + '[a]',
                    '-map', '0:v',
                    '-map', '[a]',
                    '-shortest'
                );
            }

            ffmpegArgs.push('output.mp4');

            await ffmpeg.run(...ffmpegArgs);

            // 3ë‹¨ê³„: ê²°ê³¼ ë‹¤ìš´ë¡œë“œ
            const data = ffmpeg.FS('readFile', 'output.mp4');
            const blob = new Blob([data.buffer], { type: 'video/mp4' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            const quality = getQualityText();
            const totalDuration = (duration * validImages.length + endingDuration * validEndingImages.length).toFixed(1);
            a.download = 'my-video-ffmpeg-' + quality + '-' + totalDuration + 's-' + Date.now() + '.mp4';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            // ì„ì‹œ íŒŒì¼ ì •ë¦¬
            for (let i = 0; i < frameNumber; i++) {
                const fileName = 'frame' + String(i).padStart(6, '0') + '.png';
                try { ffmpeg.FS('unlink', fileName); } catch (e) {}
            }
            try { ffmpeg.FS('unlink', 'output.mp4'); } catch (e) {}
            try { ffmpeg.FS('unlink', 'bgm.mp3'); } catch (e) {}

            updateStatus('âœ… FFmpeg ì˜ìƒ ì œì‘ ì™„ë£Œ! (ì´ ' + totalDuration + 'ì´ˆ, ' + frameNumber + ' í”„ë ˆì„)');
            updateProgressBar(0, 1);
            document.getElementById('recordBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            isRecording = false;

        } catch (error) {
            console.error('FFmpeg ë…¹í™” ì˜¤ë¥˜:', error);
            updateStatus('âŒ FFmpeg ì˜¤ë¥˜: ' + error.message);
            document.getElementById('recordBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            isRecording = false;
        }
    }

    // ê¸°ì¡´ MediaRecorder ë°©ì‹ (í´ë°±ìš©)
    async function startRecordingWithMediaRecorder() {
        const validImages = images.filter(img => img !== null);
        const validEndingImages = endingImages.filter(img => img !== null);

        try {
            stopPreview();
            stopBGM();
            recordedChunks = [];
            
            const canvas = document.getElementById('videoCanvas');
            const stream = canvas.captureStream(30);
            const bgmType = document.getElementById('bgmType').value;
            const volume = parseFloat(document.getElementById('bgmVolume').value);
            let combinedStream = stream;
            
            if (bgmType !== 'none') {
                try {
                    if (bgmType === 'custom' && customMusicFile) {
                        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        const arrayBuffer = await customMusicFile.arrayBuffer();
                        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

                        const startTime = parseFloat(document.getElementById('bgmStartTime').value) || 0;
                        const endTime = parseFloat(document.getElementById('bgmEndTime').value) || 0;

                        const source = audioContext.createBufferSource();
                        source.buffer = audioBuffer;
                        source.loop = true;

                        // êµ¬ê°„ ì„¤ì •ì´ ìˆìœ¼ë©´ ì ìš©
                        if (endTime > startTime) {
                            source.loopStart = startTime;
                            source.loopEnd = endTime;
                        }

                        const gainNode = audioContext.createGain();
                        gainNode.gain.value = volume * 0.7;
                        const dest = audioContext.createMediaStreamDestination();
                        source.connect(gainNode);
                        gainNode.connect(dest);
                        source.start(0, startTime);

                        const audioTracks = dest.stream.getAudioTracks();
                        const videoTracks = stream.getVideoTracks();
                        if (audioTracks.length > 0) {
                            combinedStream = new MediaStream([...videoTracks, ...audioTracks]);
                            const rangeInfo = endTime > startTime ? ' (' + startTime.toFixed(1) + 's ~ ' + endTime.toFixed(1) + 's)' : '';
                            updateStatus('BGMì´ í¬í•¨ëœ ì˜ìƒì„ ì œì‘í•©ë‹ˆë‹¤.' + rangeInfo);
                        }
                    } else if (bgmType !== 'custom') {
                        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        const masterGain = audioContext.createGain();
                        masterGain.gain.value = volume * 0.12;
                        const dest = audioContext.createMediaStreamDestination();
                        masterGain.connect(dest);

                        if (bgmType === 'peaceful') {
                            // ì°¨ë¶„í•œ ìŒì•…: C major ì½”ë“œ
                            [261.63, 329.63, 392.00].forEach((freq, i) => {
                                const osc = audioContext.createOscillator();
                                const gain = audioContext.createGain();
                                osc.type = 'sine';
                                osc.frequency.value = freq;
                                gain.gain.value = 0.3 - (i * 0.05);
                                osc.connect(gain);
                                gain.connect(masterGain);
                                osc.start(0);
                            });
                        } else if (bgmType === 'upbeat') {
                            // í™œê¸°ì°¬ ìŒì•…: G major ì½”ë“œ
                            [392.00, 493.88, 587.33].forEach((freq, i) => {
                                const osc = audioContext.createOscillator();
                                const gain = audioContext.createGain();
                                osc.type = 'triangle';
                                osc.frequency.value = freq;
                                gain.gain.value = 0.25;
                                osc.connect(gain);
                                gain.connect(masterGain);
                                osc.start(0);
                            });
                        } else if (bgmType === 'cinematic') {
                            // ì˜í™”ê°™ì€ ìŒì•…: Am ì½”ë“œ
                            [110.00, 130.81, 164.81, 220.00].forEach((freq, i) => {
                                const osc = audioContext.createOscillator();
                                const gain = audioContext.createGain();
                                osc.type = 'sawtooth';
                                osc.frequency.value = freq;
                                gain.gain.value = 0.2 - (i * 0.03);
                                osc.connect(gain);
                                gain.connect(masterGain);
                                osc.start(0);
                            });
                        }

                        const audioTracks = dest.stream.getAudioTracks();
                        const videoTracks = stream.getVideoTracks();
                        combinedStream = new MediaStream([...videoTracks, ...audioTracks]);
                        updateStatus('ìë™ ìƒì„± BGMì´ í¬í•¨ëœ ì˜ìƒì„ ì œì‘í•©ë‹ˆë‹¤.');
                    }
                } catch (bgmError) {
                    console.warn('BGM ì¶”ê°€ ì‹¤íŒ¨:', bgmError);
                    updateStatus('BGM ì¶”ê°€ ì‹¤íŒ¨. ë¹„ë””ì˜¤ë§Œ ë…¹í™”í•©ë‹ˆë‹¤.');
                }
            }
            
            const videoBitsPerSecond = parseInt(document.getElementById('videoQuality').value);
            
            // MP4 ì§€ì› í™•ì¸
            let options;
            if (MediaRecorder.isTypeSupported('video/mp4;codecs=h264,aac')) {
                options = { mimeType: 'video/mp4;codecs=h264,aac', videoBitsPerSecond };
            } else if (MediaRecorder.isTypeSupported('video/mp4;codecs=h264')) {
                options = { mimeType: 'video/mp4;codecs=h264', videoBitsPerSecond };
            } else if (MediaRecorder.isTypeSupported('video/mp4')) {
                options = { mimeType: 'video/mp4', videoBitsPerSecond };
            } else {
                updateStatus('âŒ MP4 í˜•ì‹ì´ ì§€ì›ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ë¸Œë¼ìš°ì €ë¥¼ ì—…ë°ì´íŠ¸í•´ì£¼ì„¸ìš”.');
                document.getElementById('recordBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
                return;
            }
            
            mediaRecorder = new MediaRecorder(combinedStream, options);

            let lastDataTimestamp = Date.now();
            let isWaitingForData = false;

            mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    recordedChunks.push(event.data);
                    lastDataTimestamp = Date.now();
                }
            };

            // ë°ì´í„° ìƒì„± í™•ì¸ í›„ ì¤‘ì§€í•˜ëŠ” í•¨ìˆ˜ (ë§¤ê°œë³€ìˆ˜ë¡œ ëŒ€ê¸° ì‹œê°„ ë°›ìŒ)
            function stopWhenReady(waitTime) {
                if (isWaitingForData) return; // ì´ë¯¸ ëŒ€ê¸° ì¤‘ì´ë©´ ì¤‘ë³µ í˜¸ì¶œ ë°©ì§€
                isWaitingForData = true;

                // waitTimeì´ ì œê³µë˜ì§€ ì•Šìœ¼ë©´ ê¸°ë³¸ê°’ 500ms ì‚¬ìš©
                const actualWaitTime = waitTime !== undefined ? waitTime : 500;

                console.log('stopWhenReady í˜¸ì¶œë¨, ' + actualWaitTime + 'ms í›„ ë…¹í™” ì¤‘ì§€ ì˜ˆì •');
                // ì§€ì •ëœ ì‹œê°„ ëŒ€ê¸° í›„ ì¤‘ì§€
                // ì´ìœ : ë§ˆì§€ë§‰ í”„ë ˆì„ì˜ ì¸ì½”ë”©ì„ ì™„ì „íˆ ë³´ì¥í•˜ê¸° ìœ„í•´ ì¶©ë¶„í•œ ì‹œê°„ ì œê³µ
                setTimeout(() => {
                    console.log('MediaRecorder ì¤‘ì§€ ì‹¤í–‰');
                    if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                        mediaRecorder.stop();
                    }
                }, actualWaitTime);
            }

            mediaRecorder.onstop = () => {
                const blob = new Blob(recordedChunks, { type: options.mimeType });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;

                const quality = getQualityText();
                const imageDuration = parseFloat(document.getElementById('imageDuration').value);
                const endingDuration = parseFloat(document.getElementById('endingImageDuration')?.value || 1);
                const totalDuration = (imageDuration * validImages.length + endingDuration * validEndingImages.length).toFixed(1);

                a.download = 'my-video-' + quality + '-' + totalDuration + 's-' + Date.now() + '.mp4';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                updateStatus(quality + ' MP4 ì˜ìƒ ì œì‘ ì™„ë£Œ! (ì´ ' + totalDuration + 'ì´ˆ)');
                updateProgressBar(0, 1);
                document.getElementById('recordBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
                stopBGM();
            };
            
            // MediaRecorder ì‹œì‘: 100ms íƒ€ì„ìŠ¬ë¼ì´ìŠ¤ë¡œ ì •í™•í•œ ë°ì´í„° ìƒì„± ì¶”ì 
            // íƒ€ì„ìŠ¬ë¼ì´ìŠ¤ë¥¼ 100msë¡œ ì„¤ì •í•˜ë©´ ondataavailableì´ ìµœì†Œ 100msë§ˆë‹¤ í˜¸ì¶œë˜ì–´
            // lastDataTimestamp ì—…ë°ì´íŠ¸ë¥¼ í†µí•´ ì‹¤ì‹œê°„ìœ¼ë¡œ ë…¹í™” ìƒíƒœë¥¼ ëª¨ë‹ˆí„°ë§ ê°€ëŠ¥
            mediaRecorder.start(100);
            isRecording = true;
            document.getElementById('recordBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;

            const duration = parseFloat(document.getElementById('imageDuration').value) * 1000;
            const endingDuration = parseFloat(document.getElementById('endingImageDuration')?.value || 1) * 1000;
            const totalFrames = validImages.length + validEndingImages.length;
            const totalDuration = ((duration * validImages.length + endingDuration * validEndingImages.length) / 1000).toFixed(1);
            updateStatus('ì˜ìƒ ì œì‘ ì‹œì‘... (ì´ ' + totalDuration + 'ì´ˆ ì˜ˆìƒ)');

            // ìœ íš¨í•œ ì—”ë”© ì´ë¯¸ì§€ì˜ ì‹¤ì œ ì¸ë±ìŠ¤ ë°°ì—´ ë¯¸ë¦¬ ìƒì„±
            const validEndingIndices = endingImages
                .map((img, index) => img !== null ? index : -1)
                .filter(index => index !== -1);

            let frameIndex = 0;
            let processedFrames = 0;

            // ì¬ê·€ ë£¨í”„ í•¨ìˆ˜ë¡œ ê° í”„ë ˆì„ ì²˜ë¦¬
            const recordingLoop = () => {
                if (!isRecording) return;

                // ë©”ì¸ ì´ë¯¸ì§€ ì²˜ë¦¬
                if (frameIndex < validImages.length) {
                    currentImageIndex = frameIndex;
                    drawCurrentImage();
                    processedFrames++;
                    updateProgressBar(processedFrames, totalFrames);
                    updateStatus('ë©”ì¸ ì´ë¯¸ì§€ ì œì‘ ì¤‘... (' + (frameIndex + 1) + '/' + validImages.length + ') - ì´ ' + totalDuration + 'ì´ˆ');

                    // ë§ˆì§€ë§‰ ë©”ì¸ ì´ë¯¸ì§€ì¸ì§€ í™•ì¸
                    const isLastMainImage = (frameIndex === validImages.length - 1);
                    const hasEndingImages = validEndingImages.length > 0;

                    frameIndex++;

                    // RAFë¡œ ë Œë”ë§ ì™„ë£Œ ë³´ì¥ í›„ íƒ€ì´ë° ì‹œì‘
                    requestAnimationFrame(() => {
                        requestAnimationFrame(() => {
                            if (!isRecording) return;

                            // ë§ˆì§€ë§‰ í”„ë ˆì„ ì²˜ë¦¬
                            if (isLastMainImage && !hasEndingImages) {
                                console.log('ë§ˆì§€ë§‰ ë©”ì¸ í”„ë ˆì„ ' + (frameIndex - 1) + ', ' + duration + 'ms ë…¹í™” í›„ ì¤‘ì§€');
                                stopWhenReady(duration);
                            } else {
                                // ì¤‘ê°„ í”„ë ˆì„: duration ëŒ€ê¸° í›„ ë‹¤ìŒ í”„ë ˆì„
                                console.log('ë©”ì¸ í”„ë ˆì„ ' + (frameIndex - 1) + ', ' + duration + 'ms ëŒ€ê¸° í›„ ë‹¤ìŒ í”„ë ˆì„');
                                setTimeout(() => {
                                    if (!isRecording) return;
                                    recordingLoop();
                                }, duration);
                            }
                        });
                    });
                }
                // ì—”ë”© ì´ë¯¸ì§€ ì²˜ë¦¬
                else {
                    const endingIndex = frameIndex - validImages.length;

                    if (endingIndex < validEndingImages.length) {
                        const actualIndex = validEndingIndices[endingIndex];

                        // ì—”ë”© ì´ë¯¸ì§€ ë Œë”ë§
                        const canvas = document.getElementById('videoCanvas');
                        const ctx = canvas.getContext('2d');
                        const img = endingImages[actualIndex];

                        if (img) {
                            ctx.clearRect(0, 0, canvas.width, canvas.height);

                            // ë°°ê²½ìƒ‰
                            const bgColor = document.getElementById('backgroundColor').value;
                            ctx.fillStyle = bgColor;
                            ctx.fillRect(0, 0, canvas.width, canvas.height);

                            // ì´ë¯¸ì§€ ê·¸ë¦¬ê¸°
                            const scaling = document.getElementById('imageScaling').value;
                            const imgAspect = img.width / img.height;
                            const canvasAspect = canvas.width / canvas.height;

                            let drawWidth, drawHeight, drawX, drawY;

                            if (scaling === 'cover') {
                                if (imgAspect > canvasAspect) {
                                    drawHeight = canvas.height;
                                    drawWidth = drawHeight * imgAspect;
                                } else {
                                    drawWidth = canvas.width;
                                    drawHeight = drawWidth / imgAspect;
                                }
                                drawX = (canvas.width - drawWidth) / 2;
                                drawY = (canvas.height - drawHeight) / 2;
                            } else {
                                if (imgAspect > canvasAspect) {
                                    drawWidth = canvas.width;
                                    drawHeight = drawWidth / imgAspect;
                                } else {
                                    drawHeight = canvas.height;
                                    drawWidth = drawHeight * imgAspect;
                                }
                                drawX = (canvas.width - drawWidth) / 2;
                                drawY = (canvas.height - drawHeight) / 2;
                            }

                            ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);

                            // ì—”ë”© ìë§‰ ê·¸ë¦¬ê¸°
                            const subtitle = endingSubtitles[actualIndex];
                            if (subtitle && subtitle.trim() !== '') {
                                const fontSize = parseInt(document.getElementById('subtitleFontSize').value);
                                const fontColor = document.getElementById('subtitleColor').value;
                                const position = document.getElementById('subtitlePosition').value;
                                const useBackground = document.getElementById('subtitleBackground').value === 'true';
                                const bgColor = document.getElementById('subtitleBgColor').value;
                                const opacity = parseFloat(document.getElementById('subtitleOpacity').value);

                                ctx.font = 'bold ' + fontSize + 'px "Malgun Gothic", "ë§‘ì€ ê³ ë”•", sans-serif';
                                ctx.textAlign = 'center';

                                const lines = subtitle.split('\n');
                                const lineHeight = fontSize * 1.3;

                                let baseY;
                                if (position === 'top') {
                                    baseY = canvas.height * 0.15;
                                } else if (position === 'center') {
                                    baseY = canvas.height / 2 - ((lines.length - 1) * lineHeight) / 2;
                                } else if (position === 'custom') {
                                    const customPos = parseFloat(document.getElementById('subtitleVerticalPosition').value) / 100;
                                    baseY = canvas.height * customPos;
                                } else {
                                    baseY = canvas.height * 0.85 - ((lines.length - 1) * lineHeight);
                                }

                                lines.forEach((line, index) => {
                                    const y = baseY + (index * lineHeight);
                                    const metrics = ctx.measureText(line);
                                    const textWidth = metrics.width;

                                    if (useBackground) {
                                        const padding = 20;
                                        ctx.fillStyle = bgColor;
                                        ctx.globalAlpha = opacity;
                                        ctx.fillRect(
                                            canvas.width / 2 - textWidth / 2 - padding,
                                            y - fontSize,
                                            textWidth + padding * 2,
                                            fontSize * 1.3
                                        );
                                        ctx.globalAlpha = 1.0;
                                    }

                                    ctx.strokeStyle = '#000000';
                                    ctx.lineWidth = fontSize * 0.1;
                                    ctx.strokeText(line, canvas.width / 2, y);

                                    ctx.fillStyle = fontColor;
                                    ctx.fillText(line, canvas.width / 2, y);
                                });
                            }
                        }

                        processedFrames++;
                        updateProgressBar(processedFrames, totalFrames);
                        updateStatus('ì—”ë”© ì´ë¯¸ì§€ ì œì‘ ì¤‘... (' + (endingIndex + 1) + '/' + validEndingImages.length + ') - ì´ ' + totalDuration + 'ì´ˆ');

                        // ë§ˆì§€ë§‰ ì—”ë”© ì´ë¯¸ì§€ì¸ì§€ í™•ì¸
                        const isLastEndingImage = (endingIndex === validEndingImages.length - 1);

                        frameIndex++;

                        // RAFë¡œ ë Œë”ë§ ì™„ë£Œ ë³´ì¥ í›„ íƒ€ì´ë° ì‹œì‘
                        requestAnimationFrame(() => {
                            requestAnimationFrame(() => {
                                if (!isRecording) return;

                                // ë§ˆì§€ë§‰ ì—”ë”© í”„ë ˆì„ ì²˜ë¦¬
                                if (isLastEndingImage) {
                                    console.log('ë§ˆì§€ë§‰ ì—”ë”© í”„ë ˆì„ ' + (endingIndex + 1) + ', ' + endingDuration + 'ms ë…¹í™” í›„ ì¤‘ì§€');
                                    stopWhenReady(endingDuration);
                                } else {
                                    // ì¤‘ê°„ ì—”ë”© í”„ë ˆì„: endingDuration ëŒ€ê¸° í›„ ë‹¤ìŒ í”„ë ˆì„
                                    console.log('ì—”ë”© í”„ë ˆì„ ' + (endingIndex + 1) + ', ' + endingDuration + 'ms ëŒ€ê¸° í›„ ë‹¤ìŒ í”„ë ˆì„');
                                    setTimeout(() => {
                                        if (!isRecording) return;
                                        recordingLoop();
                                    }, endingDuration);
                                }
                            });
                        });
                    }
                }
            };

            // ë…¹í™” ë£¨í”„ ì‹œì‘
            recordingLoop();
            
        } catch (error) {
            console.error('ë…¹í™” ì˜¤ë¥˜:', error);
            updateStatus('ë…¹í™” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
            document.getElementById('recordBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            stopBGM();
        }
    }

    function stopRecording() {
        isRecording = false;
        if (mediaRecorder && mediaRecorder.state !== 'inactive') {
            mediaRecorder.stop();
        }
        document.getElementById('recordBtn').disabled = false;
        document.getElementById('stopBtn').disabled = true;
        updateProgressBar(0, 1);
        updateStatus('ë…¹í™”ê°€ ì¤‘ì§€ë˜ì—ˆìŠµë‹ˆë‹¤.');
        stopBGM();
    }

    function getQualityText() {
        const bitrate = parseInt(document.getElementById('videoQuality').value);
        if (bitrate >= 12000000) return 'í”„ë¦¬ë¯¸ì—„í™”ì§ˆ';
        if (bitrate >= 8000000) return 'ìµœê³ í™”ì§ˆ';
        if (bitrate >= 5000000) return 'ê³ í™”ì§ˆ';
        return 'í‘œì¤€í™”ì§ˆ';
    }

    function updateStatus(message) {
        const validImages = images.filter(img => img !== null);
        const validEndingImages = endingImages.filter(img => img !== null);
        const totalImages = validImages.length + validEndingImages.length;

        let defaultMessage = 'ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•˜ê³  ì˜ìƒì„ ì œì‘í•´ë³´ì„¸ìš”!';
        if (totalImages > 0) {
            defaultMessage = validImages.length + 'ê°œ ë©”ì¸ ì´ë¯¸ì§€';
            if (validEndingImages.length > 0) {
                defaultMessage += ' + ' + validEndingImages.length + 'ê°œ ì—”ë”© ì´ë¯¸ì§€';
            }
            defaultMessage += ' ì—…ë¡œë“œë¨. ì˜ìƒì„ ì œì‘í•´ë³´ì„¸ìš”!';
        }

        document.getElementById('status').textContent = message || defaultMessage;
    }

    // ============ ì—”ë”© ì´ë¯¸ì§€ ê´€ë ¨ í•¨ìˆ˜ ============

    function initializeEndingUploadSlots() {
        const endingUploadGrid = document.getElementById('endingUploadGrid');
        endingUploadGrid.innerHTML = '';
        for (let i = 0; i < MAX_ENDING_IMAGES; i++) {
            const slot = document.createElement('div');
            slot.className = 'upload-slot';
            slot.dataset.index = i;
            slot.innerHTML = `
                <input type="file" accept="image/*" onchange="handleEndingImageUpload(${i}, this)">
                <div class="slot-number">E${i + 1}</div>
                <div style="font-size: 24px; color: #ff9800;">+</div>
            `;
            endingUploadGrid.appendChild(slot);
        }
    }

    function handleEndingImageUpload(index, input) {
        const file = input.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (e) => {
            const img = new Image();
            img.onload = () => {
                endingImages[index] = img;
                updateEndingSlot(index);
                generateEndingSubtitleInputs();
                updateStatus();
                drawCurrentImage();
            };
            img.src = e.target.result;
        };
        reader.readAsDataURL(file);
    }

    function updateEndingSlot(index) {
        const slot = document.querySelector(`#endingUploadGrid .upload-slot[data-index="${index}"]`);
        if (!slot) return;

        if (endingImages[index]) {
            slot.classList.add('has-image');
            slot.innerHTML = `
                <img src="${endingImages[index].src}" alt="Ending ${index + 1}">
                <div class="slot-number">E${index + 1}</div>
                <button class="remove-btn" onclick="removeEndingImage(${index})">Ã—</button>
            `;
        } else {
            slot.classList.remove('has-image');
            slot.innerHTML = `
                <input type="file" accept="image/*" onchange="handleEndingImageUpload(${index}, this)">
                <div class="slot-number">E${index + 1}</div>
                <div style="font-size: 24px; color: #ff9800;">+</div>
            `;
        }
    }

    function removeEndingImage(index) {
        endingImages[index] = null;
        endingSubtitles[index] = '';
        updateEndingSlot(index);
        generateEndingSubtitleInputs();
        updateStatus();
        drawCurrentImage();
    }

    function processEndingBulkUpload() {
        const input = document.getElementById('endingBulkUpload');
        const files = Array.from(input.files);

        if (files.length === 0) return;

        let uploadedCount = 0;
        let emptySlotIndex = 0;

        for (let i = 0; i < files.length && emptySlotIndex < MAX_ENDING_IMAGES; i++) {
            while (emptySlotIndex < MAX_ENDING_IMAGES && endingImages[emptySlotIndex] !== null) {
                emptySlotIndex++;
            }

            if (emptySlotIndex >= MAX_ENDING_IMAGES) break;

            const file = files[i];
            const currentIndex = emptySlotIndex;

            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    endingImages[currentIndex] = img;
                    updateEndingSlot(currentIndex);
                    uploadedCount++;

                    if (uploadedCount === Math.min(files.length, MAX_ENDING_IMAGES)) {
                        generateEndingSubtitleInputs();
                        updateStatus(uploadedCount + 'ê°œì˜ ì—”ë”© ì´ë¯¸ì§€ê°€ ì—…ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤!');
                        drawCurrentImage();
                    }
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);

            emptySlotIndex++;
        }

        input.value = '';
    }

    function clearAllEndingImages() {
        if (!confirm('ëª¨ë“  ì—”ë”© ì´ë¯¸ì§€ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) return;

        endingImages.fill(null);
        endingSubtitles.fill('');
        initializeEndingUploadSlots();
        generateEndingSubtitleInputs();
        updateStatus();
        drawCurrentImage();
    }
</script>
