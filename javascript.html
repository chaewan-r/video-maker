<script>
    // ì „ì—­ ë³€ìˆ˜
    const MAX_IMAGES = 50;
    let images = new Array(MAX_IMAGES).fill(null);
    let subtitles = new Array(MAX_IMAGES).fill('');
    let currentImageIndex = 0;
    let previewInterval = null;
    let mediaRecorder = null;
    let recordedChunks = [];
    let isRecording = false;
    let customMusicFile = null;
    let bgmAudio = null;

    // ì´ˆê¸°í™”
    document.addEventListener('DOMContentLoaded', () => {
        initializeUploadSlots();
        updateCanvasSize();
        updateOpacityDisplay();
        updateVolumeDisplay();
        updatePositionDisplay();
        updateFontSizeDisplay();
        drawCurrentImage();
    });

    // ë“œë˜ê·¸ì•¤ë“œë¡­ ê´€ë ¨ ë³€ìˆ˜
    let draggedSlotIndex = null;

    // ìŠ¬ë¡¯ HTML ìƒì„± (ì¬ì‚¬ìš©)
    function createSlotHTML(index) {
        return `
            <input type="file" accept="image/*" onchange="handleImageUpload(${index}, this)">
            <div class="slot-number">${index + 1}</div>
            <div style="font-size: 24px; color: #999;">+</div>
        `;
    }

    // ì—…ë¡œë“œ ìŠ¬ë¡¯ ì´ˆê¸°í™”
    function initializeUploadSlots() {
        const uploadGrid = document.getElementById('uploadGrid');
        uploadGrid.innerHTML = '';
        for (let i = 0; i < MAX_IMAGES; i++) {
            const slot = document.createElement('div');
            slot.className = 'upload-slot';
            slot.dataset.index = i;
            slot.innerHTML = createSlotHTML(i);
            
            // ëª¨ë“  ìŠ¬ë¡¯ì— ë“œë¡­ ì´ë²¤íŠ¸ ì¶”ê°€ (ë¹ˆ ìŠ¬ë¡¯ë„ ë“œë¡­ ê°€ëŠ¥)
            slot.addEventListener('dragover', handleDragOver);
            slot.addEventListener('drop', handleDrop);
            slot.addEventListener('dragenter', handleDragEnter);
            slot.addEventListener('dragleave', handleDragLeave);
            
            // ì´ë¯¸ì§€ê°€ ìˆëŠ” ìŠ¬ë¡¯ë§Œ ë“œë˜ê·¸ ê°€ëŠ¥
            if (images[i] !== null) {
                slot.draggable = true;
                slot.addEventListener('dragstart', handleDragStart);
                slot.addEventListener('dragend', handleDragEnd);
            }
            
            uploadGrid.appendChild(slot);
        }
    }

    // ë“œë˜ê·¸ ì‹œì‘
    function handleDragStart(e) {
        draggedSlotIndex = parseInt(this.dataset.index);
        this.classList.add('dragging');
        e.dataTransfer.effectAllowed = 'move';
    }

    function handleDragOver(e) {
        if (e.preventDefault) e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
        return false;
    }

    function handleDragEnter(e) {
        if (this !== e.target && this.classList.contains('upload-slot')) {
            this.classList.add('drag-over');
        }
    }

    function handleDragLeave(e) {
        if (this !== e.target && this.classList.contains('upload-slot')) {
            this.classList.remove('drag-over');
        }
    }

    function handleDrop(e) {
        if (e.stopPropagation) e.stopPropagation();
        this.classList.remove('drag-over');
        
        const targetSlotIndex = parseInt(this.dataset.index);
        if (draggedSlotIndex === null || draggedSlotIndex === targetSlotIndex) {
            return false;
        }
        
        // ë“œë˜ê·¸í•œ ì´ë¯¸ì§€ì™€ ìë§‰ ì„ì‹œ ì €ì¥
        const draggedImage = images[draggedSlotIndex];
        const draggedSubtitle = subtitles[draggedSlotIndex];
        
        if (!draggedImage) return false; // ì´ë¯¸ì§€ê°€ ì—†ìœ¼ë©´ ë¬´ì‹œ
        
        // ì‚½ì… ë°©ì‹ìœ¼ë¡œ ìˆœì„œ ë³€ê²½
        if (draggedSlotIndex < targetSlotIndex) {
            // ì•ì—ì„œ ë’¤ë¡œ ì´ë™: ì‚¬ì´ í•­ëª©ë“¤ì„ í•œ ì¹¸ì”© ì•ìœ¼ë¡œ ì´ë™
            for (let i = draggedSlotIndex; i < targetSlotIndex; i++) {
                images[i] = images[i + 1];
                subtitles[i] = subtitles[i + 1];
            }
            images[targetSlotIndex] = draggedImage;
            subtitles[targetSlotIndex] = draggedSubtitle;
        } else {
            // ë’¤ì—ì„œ ì•ìœ¼ë¡œ ì´ë™: ì‚¬ì´ í•­ëª©ë“¤ì„ í•œ ì¹¸ì”© ë’¤ë¡œ ì´ë™
            for (let i = draggedSlotIndex; i > targetSlotIndex; i--) {
                images[i] = images[i - 1];
                subtitles[i] = subtitles[i - 1];
            }
            images[targetSlotIndex] = draggedImage;
            subtitles[targetSlotIndex] = draggedSubtitle;
        }
        
        // UI ì—…ë°ì´íŠ¸ (ë³€ê²½ëœ ë²”ìœ„ë§Œ)
        const startIndex = Math.min(draggedSlotIndex, targetSlotIndex);
        const endIndex = Math.max(draggedSlotIndex, targetSlotIndex);
        const uploadGrid = document.getElementById('uploadGrid');
        
        for (let i = startIndex; i <= endIndex; i++) {
            const slot = uploadGrid.children[i];
            updateSlotDisplay(slot, i);
        }
        
        // í˜„ì¬ ì´ë¯¸ì§€ ì¸ë±ìŠ¤ ì—…ë°ì´íŠ¸
        const validImages = images.filter(img => img !== null);
        if (validImages.length > 0 && currentImageIndex < validImages.length) {
            const oldCurrentImage = validImages[currentImageIndex];
            if (oldCurrentImage) {
                const newValidIndex = validImages.indexOf(oldCurrentImage);
                if (newValidIndex !== -1) {
                    currentImageIndex = newValidIndex;
                }
            }
        }
        
        generateSubtitleInputs();
        drawCurrentImage();
        updateStatus('âœ… ì´ë¯¸ì§€ ìˆœì„œê°€ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤!');
        return false;
    }

    function handleDragEnd(e) {
        this.classList.remove('dragging');
        document.querySelectorAll('.upload-slot').forEach(slot => {
            slot.classList.remove('drag-over');
        });
        draggedSlotIndex = null;
    }

    // ìŠ¬ë¡¯ í‘œì‹œ ì—…ë°ì´íŠ¸
    function updateSlotDisplay(slot, index) {
        slot.dataset.index = index;
        
        if (images[index] !== null) {
            slot.classList.add('has-image');
            slot.innerHTML = `
                <input type="file" accept="image/*" onchange="handleImageUpload(${index}, this)">
                <img src="${images[index].src}" alt="ì´ë¯¸ì§€ ${index + 1}">
                <div class="slot-number">${index + 1}</div>
                <button class="remove-btn" onclick="removeImage(${index})">Ã—</button>
            `;
            slot.draggable = true;
            // ë“œë˜ê·¸ ì´ë²¤íŠ¸ë§Œ ì¶”ê°€ (ë“œë¡­ ì´ë²¤íŠ¸ëŠ” ì´ë¯¸ ìˆìŒ)
            if (!slot.hasAttribute('data-drag-listener')) {
                slot.addEventListener('dragstart', handleDragStart);
                slot.addEventListener('dragend', handleDragEnd);
                slot.setAttribute('data-drag-listener', 'true');
            }
        } else {
            slot.classList.remove('has-image');
            slot.innerHTML = createSlotHTML(index);
            slot.draggable = false;
            slot.removeAttribute('data-drag-listener');
        }
    }

    // ìº”ë²„ìŠ¤ ì´ˆê¸°í™” (ì¬ì‚¬ìš©)
    function resetCanvas() {
        const canvas = document.getElementById('videoCanvas');
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#f8f9fa';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#999';
        ctx.font = '24px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”', canvas.width/2, canvas.height/2);
    }

    // ì´ë¯¸ì§€ë§Œ ì§€ìš°ê¸°
    function clearAllImages() {
        for (let i = 0; i < MAX_IMAGES; i++) {
            images[i] = null;
        }
        initializeUploadSlots();
        resetCanvas();
        stopPreview();
        currentImageIndex = 0;
        document.getElementById('subtitleInputs').innerHTML = '<p style="text-align: center; color: #666; font-style: italic;">ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•˜ë©´ ê° ì´ë¯¸ì§€ë³„ ìë§‰ì„ ì„¤ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. (ê¸°ì¡´ ìë§‰ì€ ìœ ì§€ë©ë‹ˆë‹¤)</p>';
        updateStatus('ëª¨ë“  ì´ë¯¸ì§€ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤! (ìë§‰ì€ ìœ ì§€ë¨)');
    }

    // ê³µí†µ ìë§‰ ì ìš©
    function applyCommonSubtitle() {
        const commonText = document.getElementById('commonSubtitle').value.trim();
        if (!commonText) {
            updateStatus('ê³µí†µ ìë§‰ ë‚´ìš©ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.');
            return;
        }
        
        const validImages = images.filter(img => img !== null);
        if (validImages.length === 0) {
            updateStatus('ë¨¼ì € ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”.');
            return;
        }
        
        for (let i = 0; i < MAX_IMAGES; i++) {
            if (images[i] !== null) {
                subtitles[i] = commonText;
            }
        }
        
        generateSubtitleInputs();
        drawCurrentImage();
        updateStatus(validImages.length + 'ê°œ ì´ë¯¸ì§€ì— ê³µí†µ ìë§‰ì´ ì ìš©ë˜ì—ˆìŠµë‹ˆë‹¤.');
    }

    function clearCommonSubtitle() {
        document.getElementById('commonSubtitle').value = '';
    }

    function clearAllSubtitles() {
        for (let i = 0; i < MAX_IMAGES; i++) {
            subtitles[i] = '';
        }
        generateSubtitleInputs();
        drawCurrentImage();
        updateStatus('ëª¨ë“  ìë§‰ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤!');
    }

    // ì´ë¯¸ì§€ì™€ ìë§‰ ëª¨ë‘ ì§€ìš°ê¸°
    function forceDeleteAllImages() {
        for (let i = 0; i < MAX_IMAGES; i++) {
            images[i] = null;
            subtitles[i] = '';
        }
        initializeUploadSlots();
        document.getElementById('subtitleInputs').innerHTML = '<p style="text-align: center; color: #666; font-style: italic;">ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•˜ë©´ ê° ì´ë¯¸ì§€ë³„ ìë§‰ì„ ì„¤ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p>';
        resetCanvas();
        stopPreview();
        currentImageIndex = 0;
        updateStatus('ëª¨ë“  ì´ë¯¸ì§€ì™€ ìë§‰ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤!');
    }

    function updateFontSizeDisplay() {
        document.getElementById('fontSizeValue').textContent = document.getElementById('subtitleFontSize').value + 'px';
    }

    // ì¼ê´„ ì—…ë¡œë“œ ì²˜ë¦¬
    function processBulkUpload() {
        const bulkInput = document.getElementById('bulkUpload');
        const files = Array.from(bulkInput.files);
        if (files.length === 0) return;

        const emptySlots = [];
        for (let i = 0; i < MAX_IMAGES; i++) {
            if (images[i] === null) emptySlots.push(i);
        }

        if (emptySlots.length === 0) {
            updateStatus('ëª¨ë“  ìŠ¬ë¡¯ì´ ê°€ë“ ì°¼ìŠµë‹ˆë‹¤!');
            bulkInput.value = '';
            return;
        }

        const uploadCount = Math.min(files.length, emptySlots.length);
        let completedUploads = 0;

        files.slice(0, uploadCount).forEach((file, fileIndex) => {
            const slotIndex = emptySlots[fileIndex];
            const reader = new FileReader();
            
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    images[slotIndex] = img;
                    const slot = document.querySelectorAll('.upload-slot')[slotIndex];
                    slot.dataset.index = slotIndex;
                    slot.classList.add('has-image');
                    slot.innerHTML = `
                        <input type="file" accept="image/*" onchange="handleImageUpload(${slotIndex}, this)">
                        <img src="${event.target.result}" alt="ì´ë¯¸ì§€ ${slotIndex + 1}">
                        <div class="slot-number">${slotIndex + 1}</div>
                        <button class="remove-btn" onclick="removeImage(${slotIndex})">Ã—</button>
                    `;
                    // ë“œë˜ê·¸ ê°€ëŠ¥í•˜ê²Œ ì„¤ì •
                    slot.draggable = true;
                    slot.addEventListener('dragstart', handleDragStart);
                    slot.addEventListener('dragover', handleDragOver);
                    slot.addEventListener('drop', handleDrop);
                    slot.addEventListener('dragend', handleDragEnd);
                    slot.addEventListener('dragenter', handleDragEnter);
                    slot.addEventListener('dragleave', handleDragLeave);
                    
                    completedUploads++;
                    if (completedUploads === uploadCount) {
                        generateSubtitleInputs();
                        updateStatus();
                        bulkInput.value = '';
                        drawCurrentImage();
                    }
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        });

        if (files.length > emptySlots.length) {
            updateStatus(emptySlots.length + 'ê°œ ìŠ¬ë¡¯ë§Œ ì‚¬ìš© ê°€ëŠ¥í•˜ì—¬ ' + uploadCount + 'ê°œ ì´ë¯¸ì§€ë§Œ ì—…ë¡œë“œë©ë‹ˆë‹¤.');
        }
    }

    // ì´ë¯¸ì§€ ì—…ë¡œë“œ ì²˜ë¦¬
    function handleImageUpload(index, input) {
        const file = input.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (event) => {
            const img = new Image();
            img.onload = () => {
                images[index] = img;
                const slot = input.parentElement;
                slot.dataset.index = index;
                slot.classList.add('has-image');
                slot.innerHTML = `
                    <input type="file" accept="image/*" onchange="handleImageUpload(${index}, this)">
                    <img src="${event.target.result}" alt="ì´ë¯¸ì§€ ${index + 1}">
                    <div class="slot-number">${index + 1}</div>
                    <button class="remove-btn" onclick="removeImage(${index})">Ã—</button>
                `;
                // ë“œë˜ê·¸ ê°€ëŠ¥í•˜ê²Œ ì„¤ì •
                slot.draggable = true;
                slot.addEventListener('dragstart', handleDragStart);
                slot.addEventListener('dragover', handleDragOver);
                slot.addEventListener('drop', handleDrop);
                slot.addEventListener('dragend', handleDragEnd);
                slot.addEventListener('dragenter', handleDragEnter);
                slot.addEventListener('dragleave', handleDragLeave);
                
                generateSubtitleInputs();
                updateStatus();
                drawCurrentImage();
            };
            img.src = event.target.result;
        };
        reader.readAsDataURL(file);
    }

    // ì´ë¯¸ì§€ ì œê±°
    function removeImage(index) {
        images[index] = null;
        subtitles[index] = '';
        const slot = document.querySelectorAll('.upload-slot')[index];
        slot.classList.remove('has-image');
        slot.innerHTML = createSlotHTML(index);
        slot.draggable = false;
        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì œê±°
        slot.removeEventListener('dragstart', handleDragStart);
        slot.removeEventListener('dragover', handleDragOver);
        slot.removeEventListener('drop', handleDrop);
        slot.removeEventListener('dragend', handleDragEnd);
        slot.removeEventListener('dragenter', handleDragEnter);
        slot.removeEventListener('dragleave', handleDragLeave);
        generateSubtitleInputs();
        updateStatus();
        drawCurrentImage();
    }

    // ìë§‰ ì…ë ¥ í•„ë“œ ìƒì„±
    function generateSubtitleInputs() {
        const container = document.getElementById('subtitleInputs');
        const validImageIndices = images.map((img, index) => img !== null ? index : -1).filter(index => index !== -1);
        
        if (validImageIndices.length === 0) {
            container.innerHTML = '<p style="text-align: center; color: #666; font-style: italic;">ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•˜ë©´ ê° ì´ë¯¸ì§€ë³„ ìë§‰ì„ ì„¤ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p>';
            return;
        }
        
        container.innerHTML = validImageIndices.map(index => `
            <div style="background: #fff; padding: 20px; border-radius: 10px; border: 1px solid #ddd;">
                <label style="display: block; margin-bottom: 10px; font-weight: bold; color: #333;">
                    ì´ë¯¸ì§€ ${index + 1}ë²ˆ ìë§‰:
                </label>
                <textarea 
                    placeholder="ì´ ì´ë¯¸ì§€ì— í‘œì‹œí•  ìë§‰ì„ ì…ë ¥í•˜ì„¸ìš”..."
                    style="width: 100%; padding: 10px; border: 2px solid #e9ecef; border-radius: 8px; font-size: 14px; resize: vertical; min-height: 80px;"
                    oninput="updateSubtitle(${index}, this.value)"
                >${subtitles[index] || ''}</textarea>
            </div>
        `).join('');
    }

    function updateSubtitle(index, value) {
        subtitles[index] = value;
        previewSubtitle();
    }

    function previewSubtitle() {
        document.getElementById('customPositionGroup').style.display = 
            document.getElementById('subtitlePosition').value === 'custom' ? 'block' : 'none';
        drawCurrentImage();
    }

    function updateOpacityDisplay() {
        document.getElementById('opacityValue').textContent = 
            Math.round(document.getElementById('subtitleOpacity').value * 100) + '%';
    }

    function updatePositionDisplay() {
        document.getElementById('positionValue').textContent = 
            document.getElementById('subtitleVerticalPosition').value + '%';
    }

    function updateVolumeDisplay() {
        document.getElementById('volumeValue').textContent =
            Math.round(document.getElementById('bgmVolume').value * 100) + '%';
    }

    function updateBGMRangeDisplay() {
        const startTime = parseFloat(document.getElementById('bgmStartTime').value);
        const endTime = parseFloat(document.getElementById('bgmEndTime').value);

        document.getElementById('bgmStartDisplay').textContent = startTime.toFixed(1);
        document.getElementById('bgmEndDisplay').textContent = endTime.toFixed(1);

        if (endTime > startTime) {
            document.getElementById('bgmDurationDisplay').textContent = (endTime - startTime).toFixed(1);
        } else {
            document.getElementById('bgmDurationDisplay').textContent = 'ì „ì²´';
        }
    }

    function handleBGMTypeChange() {
        const customSection = document.getElementById('customMusicSection');
        const timingSection = document.getElementById('bgmTimingSection');
        const isCustom = document.getElementById('bgmType').value === 'custom';
        customSection.style.display = isCustom ? 'block' : 'none';
        timingSection.style.display = isCustom ? 'block' : 'none';

        if (!isCustom) {
            stopBGM();
            customMusicFile = null;
            document.getElementById('musicInfo').style.display = 'none';
        }
    }

    function handleMusicUpload(input) {
        const file = input.files[0];
        if (!file) return;

        if (!file.name.toLowerCase().endsWith('.mp3')) {
            updateStatus('MP3 íŒŒì¼ë§Œ ì§€ì›ë©ë‹ˆë‹¤!');
            input.value = '';
            return;
        }

        if (file.size > 10 * 1024 * 1024) {
            updateStatus('íŒŒì¼ í¬ê¸°ê°€ ë„ˆë¬´ í½ë‹ˆë‹¤. 10MB ì´í•˜ì˜ íŒŒì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”.');
            input.value = '';
            return;
        }

        customMusicFile = file;
        document.getElementById('musicName').textContent = 'ğŸµ ' + file.name;
        document.getElementById('musicSize').textContent = 'ğŸ“ í¬ê¸°: ' + (file.size / 1024 / 1024).toFixed(1) + 'MB';
        document.getElementById('musicInfo').style.display = 'block';
        updateStatus('MP3 íŒŒì¼ ì—…ë¡œë“œ ì™„ë£Œ: ' + file.name);
    }

    function previewBGM() {
        const bgmType = document.getElementById('bgmType').value;
        const volume = parseFloat(document.getElementById('bgmVolume').value);
        
        if (bgmType === 'none') {
            updateStatus('BGMì„ ì„ íƒí•´ì£¼ì„¸ìš”!');
            return;
        }

        stopBGM();

        if (bgmType === 'custom') {
            if (!customMusicFile) {
                updateStatus('ë¨¼ì € MP3 íŒŒì¼ì„ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”!');
                return;
            }

            try {
                const startTime = parseFloat(document.getElementById('bgmStartTime').value) || 0;
                const endTime = parseFloat(document.getElementById('bgmEndTime').value) || 0;

                bgmAudio = new Audio();
                bgmAudio.src = URL.createObjectURL(customMusicFile);
                bgmAudio.volume = volume;
                bgmAudio.loop = false;
                bgmAudio.currentTime = startTime;

                bgmAudio.addEventListener('loadeddata', () => {
                    const duration = endTime > startTime ? endTime - startTime : 10;
                    updateStatus('ì»¤ìŠ¤í…€ MP3 ë¯¸ë¦¬ë“£ê¸° ì¤‘... (' + Math.min(duration, 10).toFixed(1) + 'ì´ˆ)');
                    bgmAudio.play();

                    // ì¢…ë£Œ ì‹œì  ì²´í¬
                    if (endTime > startTime) {
                        const checkInterval = setInterval(() => {
                            if (bgmAudio && bgmAudio.currentTime >= endTime) {
                                clearInterval(checkInterval);
                                stopBGM();
                                updateStatus();
                            }
                        }, 100);
                        bgmAudio.dataset.checkInterval = checkInterval;
                    }

                    setTimeout(() => { stopBGM(); updateStatus(); }, Math.min(duration, 10) * 1000);
                });

                bgmAudio.addEventListener('error', () => {
                    updateStatus('MP3 íŒŒì¼ì„ ì¬ìƒí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                    stopBGM();
                });
            } catch (error) {
                updateStatus('ì»¤ìŠ¤í…€ ìŒì•… ì¬ìƒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
            }
        } else {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const masterGain = audioContext.createGain();
                masterGain.gain.value = volume * 0.15;
                masterGain.connect(audioContext.destination);

                const oscillators = [];

                if (bgmType === 'peaceful') {
                    // ì°¨ë¶„í•œ ìŒì•…: C major ì½”ë“œ (C, E, G)
                    [261.63, 329.63, 392.00].forEach((freq, i) => {
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        osc.type = 'sine';
                        osc.frequency.value = freq;
                        gain.gain.value = 0.3 - (i * 0.05);
                        osc.connect(gain);
                        gain.connect(masterGain);
                        osc.start();
                        oscillators.push(osc);
                    });
                } else if (bgmType === 'upbeat') {
                    // í™œê¸°ì°¬ ìŒì•…: G major ì½”ë“œ + ë¦¬ë“¬
                    [392.00, 493.88, 587.33].forEach((freq, i) => {
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        osc.type = 'triangle';
                        osc.frequency.value = freq;
                        gain.gain.value = 0.25;

                        // ë¦¬ë“¬ê° ì¶”ê°€
                        gain.gain.setValueAtTime(0.25, audioContext.currentTime);
                        for (let t = 0; t < 5; t += 0.5) {
                            gain.gain.setValueAtTime(0.35, audioContext.currentTime + t);
                            gain.gain.setValueAtTime(0.15, audioContext.currentTime + t + 0.25);
                        }

                        osc.connect(gain);
                        gain.connect(masterGain);
                        osc.start();
                        oscillators.push(osc);
                    });
                } else if (bgmType === 'cinematic') {
                    // ì˜í™”ê°™ì€ ìŒì•…: Am ì½”ë“œ (A, C, E) - ë‚®ì€ ìŒì—­
                    [110.00, 130.81, 164.81, 220.00].forEach((freq, i) => {
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        osc.type = 'sawtooth';
                        osc.frequency.value = freq;
                        gain.gain.value = 0.2 - (i * 0.03);

                        // ì ì§„ì  ë³¼ë¥¨ ì¦ê°€ (ì˜í™” ê°™ì€ íš¨ê³¼)
                        gain.gain.setValueAtTime(0, audioContext.currentTime);
                        gain.gain.linearRampToValueAtTime(gain.gain.value, audioContext.currentTime + 1);

                        osc.connect(gain);
                        gain.connect(masterGain);
                        osc.start();
                        oscillators.push(osc);
                    });
                }

                bgmAudio = { oscillators, audioContext };

                const bgmNames = { 'peaceful': 'ì°¨ë¶„í•œ', 'upbeat': 'í™œê¸°ì°¬', 'cinematic': 'ì˜í™”ê°™ì€' };
                updateStatus(bgmNames[bgmType] + ' BGM ë¯¸ë¦¬ë“£ê¸° ì¤‘... (10ì´ˆ í›„ ìë™ ì •ì§€)');
                setTimeout(() => { stopBGM(); updateStatus(); }, 10000);
            } catch (error) {
                updateStatus('BGM ì¬ìƒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
            }
        }
    }

    function stopBGMPreview() {
        stopBGM();
        updateStatus();
    }

    function stopBGM() {
        if (bgmAudio) {
            try {
                if (bgmAudio.pause) {
                    // ì»¤ìŠ¤í…€ MP3 íŒŒì¼ ì •ì§€
                    bgmAudio.pause();
                    bgmAudio.currentTime = 0;
                    if (bgmAudio.src && bgmAudio.src.startsWith('blob:')) {
                        URL.revokeObjectURL(bgmAudio.src);
                    }
                } else if (bgmAudio.oscillators) {
                    // ì—¬ëŸ¬ ì˜¤ì‹¤ë ˆì´í„° ì •ì§€
                    bgmAudio.oscillators.forEach(osc => {
                        try { osc.stop(); } catch (e) {}
                    });
                    bgmAudio.audioContext.close();
                } else if (bgmAudio.oscillator) {
                    // ë‹¨ì¼ ì˜¤ì‹¤ë ˆì´í„° ì •ì§€ (í•˜ìœ„ í˜¸í™˜ì„±)
                    bgmAudio.oscillator.stop();
                    bgmAudio.audioContext.close();
                }
            } catch (e) {}
            bgmAudio = null;
        }
    }

    function updateCanvasSize() {
        const [width, height] = document.getElementById('videoSize').value.split(',').map(Number);
        const canvas = document.getElementById('videoCanvas');
        canvas.width = width;
        canvas.height = height;
        
        const maxDisplayWidth = 500;
        const maxDisplayHeight = 400;
        const aspectRatio = width / height;
        
        if (width > height) {
            canvas.style.width = maxDisplayWidth + 'px';
            canvas.style.height = (maxDisplayWidth / aspectRatio) + 'px';
        } else {
            canvas.style.height = maxDisplayHeight + 'px';
            canvas.style.width = (maxDisplayHeight * aspectRatio) + 'px';
        }
        
        const ratios = { '1920,1080': '16:9', '1080,1920': '9:16', '1080,1350': '4:5', '1080,1080': '1:1' };
        document.getElementById('ratioIndicator').textContent = ratios[width + ',' + height] || '';
        
        drawCurrentImage();
    }

    function drawCurrentImage() {
        const canvas = document.getElementById('videoCanvas');
        const ctx = canvas.getContext('2d');
        const validImages = images.filter(img => img !== null);
        
        ctx.fillStyle = document.getElementById('backgroundColor').value;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        if (validImages.length === 0) {
            ctx.fillStyle = '#999';
            ctx.font = '24px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”', canvas.width/2, canvas.height/2);
            return;
        }
        
        const img = validImages[currentImageIndex % validImages.length];
        if (!img) return;
        
        const canvasAspect = canvas.width / canvas.height;
        const imgAspect = img.width / img.height;
        const imageScaling = document.getElementById('imageScaling').value;
        let drawWidth, drawHeight, drawX, drawY;
        
        if (imageScaling === 'contain') {
            if (imgAspect > canvasAspect) {
                drawWidth = canvas.width;
                drawHeight = drawWidth / imgAspect;
                drawX = 0;
                drawY = (canvas.height - drawHeight) / 2;
            } else {
                drawHeight = canvas.height;
                drawWidth = drawHeight * imgAspect;
                drawX = (canvas.width - drawWidth) / 2;
                drawY = 0;
            }
        } else {
            if (imgAspect > canvasAspect) {
                drawHeight = canvas.height;
                drawWidth = drawHeight * imgAspect;
                drawX = (canvas.width - drawWidth) / 2;
                drawY = 0;
            } else {
                drawWidth = canvas.width;
                drawHeight = drawWidth / imgAspect;
                drawX = 0;
                drawY = (canvas.height - drawHeight) / 2;
            }
        }
        
        ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
        drawSubtitle(ctx, currentImageIndex, canvas.width, canvas.height);
    }

    function drawSubtitle(ctx, imageIndex, canvasWidth, canvasHeight) {
        const validImageIndices = images.map((img, index) => img !== null ? index : -1).filter(index => index !== -1);
        if (validImageIndices.length === 0) return;
        
        const actualImageIndex = validImageIndices[imageIndex % validImageIndices.length];
        const text = subtitles[actualImageIndex];
        if (!text || text.trim() === '') return;
        
        const fontSize = parseInt(document.getElementById('subtitleFontSize').value);
        const fontColor = document.getElementById('subtitleColor').value;
        const subtitlePositionType = document.getElementById('subtitlePosition').value;
        const hasBackground = document.getElementById('subtitleBackground').value === 'true';
        const bgColor = document.getElementById('subtitleBgColor').value;
        const opacity = parseFloat(document.getElementById('subtitleOpacity').value);
        
        ctx.font = 'bold ' + fontSize + 'px -apple-system, BlinkMacSystemFont, "Malgun Gothic", "ë§‘ì€ ê³ ë”•", "Segoe UI", Roboto, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        const maxWidth = canvasWidth * 0.9;
        const words = text.split(' ');
        const lines = [];
        let currentLine = words[0] || '';
        
        for (let i = 1; i < words.length; i++) {
            const word = words[i];
            const width = ctx.measureText(currentLine + " " + word).width;
            if (width < maxWidth) {
                currentLine += " " + word;
            } else {
                lines.push(currentLine);
                currentLine = word;
            }
        }
        if (currentLine) lines.push(currentLine);
        
        const lineHeight = fontSize * 1.2;
        const totalHeight = lines.length * lineHeight;
        
        let startY;
        if (subtitlePositionType === 'custom') {
            const customPosition = parseFloat(document.getElementById('subtitleVerticalPosition').value);
            startY = (canvasHeight * customPosition / 100) + (lineHeight / 2);
        } else {
            const positions = {
                'top': totalHeight / 2 + 50,
                'center': canvasHeight / 2 - (totalHeight / 2) + lineHeight / 2,
                'bottom': canvasHeight - totalHeight / 2 - 50
            };
            startY = positions[subtitlePositionType] || positions['bottom'];
        }
        
        lines.forEach((line, index) => {
            const x = canvasWidth / 2;
            const y = startY + (index * lineHeight);
            
            if (hasBackground) {
                const textWidth = ctx.measureText(line).width;
                const padding = 20;
                ctx.fillStyle = bgColor + Math.round(opacity * 255).toString(16).padStart(2, '0');
                ctx.fillRect(x - textWidth / 2 - padding, y - fontSize / 2 - padding / 2, textWidth + padding * 2, fontSize + padding);
            }
            
            ctx.fillStyle = fontColor;
            ctx.fillText(line, x, y);
        });
    }

    function startPreview() {
        const validImages = images.filter(img => img !== null);
        if (validImages.length === 0) {
            updateStatus('ë¨¼ì € ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”!');
            return;
        }

        stopPreview();
        const duration = parseFloat(document.getElementById('imageDuration').value) * 1000;
        currentImageIndex = 0;

        drawCurrentImage();
        updateProgressBar(0, validImages.length);

        previewInterval = setInterval(() => {
            currentImageIndex = (currentImageIndex + 1) % validImages.length;
            drawCurrentImage();
            updateProgressBar(currentImageIndex, validImages.length);
        }, duration);

        // BGM ë¯¸ë¦¬ë³´ê¸° ì¬ìƒ
        startPreviewBGM();

        updateStatus('ë¯¸ë¦¬ë³´ê¸° ì¬ìƒ ì¤‘... (BGM í¬í•¨)');
    }

    function startPreviewBGM() {
        const bgmType = document.getElementById('bgmType').value;
        const volume = parseFloat(document.getElementById('bgmVolume').value);

        if (bgmType === 'none') return;

        stopBGM();

        if (bgmType === 'custom' && customMusicFile) {
            try {
                const startTime = parseFloat(document.getElementById('bgmStartTime').value) || 0;
                const endTime = parseFloat(document.getElementById('bgmEndTime').value) || 0;

                bgmAudio = new Audio();
                bgmAudio.src = URL.createObjectURL(customMusicFile);
                bgmAudio.volume = volume;
                bgmAudio.loop = true;
                bgmAudio.currentTime = startTime;

                bgmAudio.addEventListener('loadeddata', () => {
                    bgmAudio.play();

                    // ì¢…ë£Œ ì‹œì  ì²´í¬ (ë£¨í”„)
                    if (endTime > startTime) {
                        const checkInterval = setInterval(() => {
                            if (bgmAudio && bgmAudio.currentTime >= endTime) {
                                bgmAudio.currentTime = startTime;
                            }
                        }, 100);
                        bgmAudio.dataset.checkInterval = checkInterval;
                    }
                });
            } catch (error) {
                console.warn('BGM ë¯¸ë¦¬ë³´ê¸° ì‹¤íŒ¨:', error);
            }
        } else if (bgmType !== 'custom' && bgmType !== 'none') {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const masterGain = audioContext.createGain();
                masterGain.gain.value = volume * 0.15;
                masterGain.connect(audioContext.destination);

                const oscillators = [];

                if (bgmType === 'peaceful') {
                    [261.63, 329.63, 392.00].forEach((freq, i) => {
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        osc.type = 'sine';
                        osc.frequency.value = freq;
                        gain.gain.value = 0.3 - (i * 0.05);
                        osc.connect(gain);
                        gain.connect(masterGain);
                        osc.start();
                        oscillators.push(osc);
                    });
                } else if (bgmType === 'upbeat') {
                    [392.00, 493.88, 587.33].forEach((freq, i) => {
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        osc.type = 'triangle';
                        osc.frequency.value = freq;
                        gain.gain.value = 0.25;

                        gain.gain.setValueAtTime(0.25, audioContext.currentTime);
                        for (let t = 0; t < 60; t += 0.5) {
                            gain.gain.setValueAtTime(0.35, audioContext.currentTime + t);
                            gain.gain.setValueAtTime(0.15, audioContext.currentTime + t + 0.25);
                        }

                        osc.connect(gain);
                        gain.connect(masterGain);
                        osc.start();
                        oscillators.push(osc);
                    });
                } else if (bgmType === 'cinematic') {
                    [110.00, 130.81, 164.81, 220.00].forEach((freq, i) => {
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        osc.type = 'sawtooth';
                        osc.frequency.value = freq;
                        gain.gain.value = 0.2 - (i * 0.03);

                        gain.gain.setValueAtTime(0, audioContext.currentTime);
                        gain.gain.linearRampToValueAtTime(gain.gain.value, audioContext.currentTime + 1);

                        osc.connect(gain);
                        gain.connect(masterGain);
                        osc.start();
                        oscillators.push(osc);
                    });
                }

                bgmAudio = { oscillators, audioContext };
            } catch (error) {
                console.warn('BGM ë¯¸ë¦¬ë³´ê¸° ì‹¤íŒ¨:', error);
            }
        }
    }

    function stopPreview() {
        if (previewInterval) {
            clearInterval(previewInterval);
            previewInterval = null;
        }
        stopBGM();
        updateProgressBar(0, 1);
        updateStatus();
    }

    function updateProgressBar(current, total) {
        document.getElementById('progressFill').style.width = (total > 0 ? (current / total) * 100 : 0) + '%';
    }

    async function startRecording() {
        const validImages = images.filter(img => img !== null);
        if (validImages.length === 0) {
            updateStatus('ë¨¼ì € ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”!');
            return;
        }

        try {
            stopPreview();
            stopBGM();
            recordedChunks = [];
            
            const canvas = document.getElementById('videoCanvas');
            const stream = canvas.captureStream(30);
            const bgmType = document.getElementById('bgmType').value;
            const volume = parseFloat(document.getElementById('bgmVolume').value);
            let combinedStream = stream;
            
            if (bgmType !== 'none') {
                try {
                    if (bgmType === 'custom' && customMusicFile) {
                        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        const arrayBuffer = await customMusicFile.arrayBuffer();
                        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

                        const startTime = parseFloat(document.getElementById('bgmStartTime').value) || 0;
                        const endTime = parseFloat(document.getElementById('bgmEndTime').value) || 0;

                        const source = audioContext.createBufferSource();
                        source.buffer = audioBuffer;
                        source.loop = true;

                        // êµ¬ê°„ ì„¤ì •ì´ ìˆìœ¼ë©´ ì ìš©
                        if (endTime > startTime) {
                            source.loopStart = startTime;
                            source.loopEnd = endTime;
                        }

                        const gainNode = audioContext.createGain();
                        gainNode.gain.value = volume * 0.7;
                        const dest = audioContext.createMediaStreamDestination();
                        source.connect(gainNode);
                        gainNode.connect(dest);
                        source.start(0, startTime);

                        const audioTracks = dest.stream.getAudioTracks();
                        const videoTracks = stream.getVideoTracks();
                        if (audioTracks.length > 0) {
                            combinedStream = new MediaStream([...videoTracks, ...audioTracks]);
                            const rangeInfo = endTime > startTime ? ' (' + startTime.toFixed(1) + 's ~ ' + endTime.toFixed(1) + 's)' : '';
                            updateStatus('BGMì´ í¬í•¨ëœ ì˜ìƒì„ ì œì‘í•©ë‹ˆë‹¤.' + rangeInfo);
                        }
                    } else if (bgmType !== 'custom') {
                        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        const masterGain = audioContext.createGain();
                        masterGain.gain.value = volume * 0.12;
                        const dest = audioContext.createMediaStreamDestination();
                        masterGain.connect(dest);

                        if (bgmType === 'peaceful') {
                            // ì°¨ë¶„í•œ ìŒì•…: C major ì½”ë“œ
                            [261.63, 329.63, 392.00].forEach((freq, i) => {
                                const osc = audioContext.createOscillator();
                                const gain = audioContext.createGain();
                                osc.type = 'sine';
                                osc.frequency.value = freq;
                                gain.gain.value = 0.3 - (i * 0.05);
                                osc.connect(gain);
                                gain.connect(masterGain);
                                osc.start(0);
                            });
                        } else if (bgmType === 'upbeat') {
                            // í™œê¸°ì°¬ ìŒì•…: G major ì½”ë“œ
                            [392.00, 493.88, 587.33].forEach((freq, i) => {
                                const osc = audioContext.createOscillator();
                                const gain = audioContext.createGain();
                                osc.type = 'triangle';
                                osc.frequency.value = freq;
                                gain.gain.value = 0.25;
                                osc.connect(gain);
                                gain.connect(masterGain);
                                osc.start(0);
                            });
                        } else if (bgmType === 'cinematic') {
                            // ì˜í™”ê°™ì€ ìŒì•…: Am ì½”ë“œ
                            [110.00, 130.81, 164.81, 220.00].forEach((freq, i) => {
                                const osc = audioContext.createOscillator();
                                const gain = audioContext.createGain();
                                osc.type = 'sawtooth';
                                osc.frequency.value = freq;
                                gain.gain.value = 0.2 - (i * 0.03);
                                osc.connect(gain);
                                gain.connect(masterGain);
                                osc.start(0);
                            });
                        }

                        const audioTracks = dest.stream.getAudioTracks();
                        const videoTracks = stream.getVideoTracks();
                        combinedStream = new MediaStream([...videoTracks, ...audioTracks]);
                        updateStatus('ìë™ ìƒì„± BGMì´ í¬í•¨ëœ ì˜ìƒì„ ì œì‘í•©ë‹ˆë‹¤.');
                    }
                } catch (bgmError) {
                    console.warn('BGM ì¶”ê°€ ì‹¤íŒ¨:', bgmError);
                    updateStatus('BGM ì¶”ê°€ ì‹¤íŒ¨. ë¹„ë””ì˜¤ë§Œ ë…¹í™”í•©ë‹ˆë‹¤.');
                }
            }
            
            const videoBitsPerSecond = parseInt(document.getElementById('videoQuality').value);
            
            // MP4 ì§€ì› í™•ì¸
            let options;
            if (MediaRecorder.isTypeSupported('video/mp4;codecs=h264,aac')) {
                options = { mimeType: 'video/mp4;codecs=h264,aac', videoBitsPerSecond };
            } else if (MediaRecorder.isTypeSupported('video/mp4;codecs=h264')) {
                options = { mimeType: 'video/mp4;codecs=h264', videoBitsPerSecond };
            } else if (MediaRecorder.isTypeSupported('video/mp4')) {
                options = { mimeType: 'video/mp4', videoBitsPerSecond };
            } else {
                updateStatus('âŒ MP4 í˜•ì‹ì´ ì§€ì›ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ë¸Œë¼ìš°ì €ë¥¼ ì—…ë°ì´íŠ¸í•´ì£¼ì„¸ìš”.');
                document.getElementById('recordBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
                return;
            }
            
            mediaRecorder = new MediaRecorder(combinedStream, options);
            
            mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) recordedChunks.push(event.data);
            };
            
            mediaRecorder.onstop = () => {
                const blob = new Blob(recordedChunks, { type: options.mimeType });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                
                const quality = getQualityText();
                const imageDuration = parseFloat(document.getElementById('imageDuration').value);
                const totalDuration = (imageDuration * validImages.length).toFixed(1);
                
                a.download = 'my-video-' + quality + '-' + totalDuration + 's-' + Date.now() + '.mp4';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                updateStatus(quality + ' MP4 ì˜ìƒ ì œì‘ ì™„ë£Œ! (ì´ ' + totalDuration + 'ì´ˆ)');
                updateProgressBar(0, 1);
                document.getElementById('recordBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
                stopBGM();
            };
            
            mediaRecorder.start();
            isRecording = true;
            document.getElementById('recordBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            
            const duration = parseFloat(document.getElementById('imageDuration').value) * 1000;
            const totalFrames = validImages.length;
            const totalDuration = (duration * totalFrames / 1000).toFixed(1);
            updateStatus('ì˜ìƒ ì œì‘ ì‹œì‘... (ì´ ' + totalDuration + 'ì´ˆ ì˜ˆìƒ)');
            
            currentImageIndex = 0;
            drawCurrentImage();
            await new Promise(resolve => requestAnimationFrame(resolve));
            await new Promise(resolve => requestAnimationFrame(resolve));
            
            for (let frameIndex = 0; frameIndex < totalFrames && isRecording; frameIndex++) {
                currentImageIndex = frameIndex;
                drawCurrentImage();
                await new Promise(resolve => requestAnimationFrame(resolve));

                updateProgressBar(frameIndex + 1, totalFrames);
                updateStatus('ì˜ìƒ ì œì‘ ì¤‘... (' + (frameIndex + 1) + '/' + totalFrames + ') - ì´ ' + totalDuration + 'ì´ˆ');

                const frameStartTime = performance.now();
                while (isRecording && (performance.now() - frameStartTime) < duration) {
                    await new Promise(resolve => setTimeout(resolve, 16));
                }
            }

            // ë§ˆì§€ë§‰ í”„ë ˆì„ì˜ ì™„ì „í•œ duration ë³´ì¥ (100ms ë²„í¼ ì¶”ê°€)
            if (isRecording) {
                await new Promise(resolve => setTimeout(resolve, duration + 100));
            }

            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }
            
        } catch (error) {
            console.error('ë…¹í™” ì˜¤ë¥˜:', error);
            updateStatus('ë…¹í™” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
            document.getElementById('recordBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            stopBGM();
        }
    }

    function stopRecording() {
        isRecording = false;
        if (mediaRecorder && mediaRecorder.state !== 'inactive') {
            mediaRecorder.stop();
        }
        document.getElementById('recordBtn').disabled = false;
        document.getElementById('stopBtn').disabled = true;
        updateProgressBar(0, 1);
        updateStatus('ë…¹í™”ê°€ ì¤‘ì§€ë˜ì—ˆìŠµë‹ˆë‹¤.');
        stopBGM();
    }

    function getQualityText() {
        const bitrate = parseInt(document.getElementById('videoQuality').value);
        if (bitrate >= 12000000) return 'í”„ë¦¬ë¯¸ì—„í™”ì§ˆ';
        if (bitrate >= 8000000) return 'ìµœê³ í™”ì§ˆ';
        if (bitrate >= 5000000) return 'ê³ í™”ì§ˆ';
        return 'í‘œì¤€í™”ì§ˆ';
    }

    function updateStatus(message) {
        const validImages = images.filter(img => img !== null);
        const defaultMessage = validImages.length > 0 
            ? validImages.length + 'ê°œ ì´ë¯¸ì§€ ì—…ë¡œë“œë¨. ì˜ìƒì„ ì œì‘í•´ë³´ì„¸ìš”!'
            : 'ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•˜ê³  ì˜ìƒì„ ì œì‘í•´ë³´ì„¸ìš”!';
        document.getElementById('status').textContent = message || defaultMessage;
    }
</script>
